<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Backbone-game-engine by bbert81</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Backbone-game-engine</h1>
      <h2 class="project-tagline">HTML5 Game Engine using Backbone.</h2>
      <a href="https://github.com/bbert81/backbone-game-engine" class="btn">View on GitHub</a>
      <a href="https://github.com/bbert81/backbone-game-engine/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/bbert81/backbone-game-engine/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p>&lt;!DOCTYPE html&gt;

  </p>
    Backbone Game Engine
    
    
    
    
    
    

<pre><code>&lt;script src="docs/jquery.min.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="docs/bootstrap.min.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;link href="docs/bootstrap.min.css" rel="stylesheet" type="text/css" charset="utf-8"&gt;

&lt;link href="docs/docs.css" rel="stylesheet" type="text/css" charset="utf-8"&gt;
</code></pre>

<p></p>

<p></p>
     
      <div>
        
          Toggle navigation
          
          
          
        
        <a href="index.html" title="Elementary HTML5 Canvas Game Engine based on Backbone."><img src="apple_touch_icon.png"> Backbone Game Engine</a>
      </div>
      <div id="navbar-collapse">
        <ul>
          <li><a href="index.html">Documentation</a></li>
          <li><a href="examples.html">Examples</a></li>
        </ul>
        <ul>
          <li><a href="https://github.com/martindrapeau/backbone-game-engine" title="Fork me on Github"><img src="docs/github.png">Github</a></li>
        </ul>
      </div>
     

<pre><code>&lt;div class="container"&gt;
&lt;div class="row"&gt;

&lt;div class="col-md-9"&gt;
  &lt;div id="introduction" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h1&gt;HTML5 Canvas &amp;amp; Backbone&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="row"&gt;
    &lt;div class="col-md-6 col-xs-6"&gt;
      &lt;p&gt;
        An elementary HTML5 Canvas game engine built on Backbone. Specialized for 2D platformers, and optimized for mobile.
      &lt;/p&gt;
      &lt;h4&gt;Examples&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;Real game: &lt;a href="http://www.ludosquest.com" target="_blank"&gt;Ludo's Quest&lt;/a&gt; - &lt;a href="https://itunes.apple.com/ca/app/ludos-quest/id1047863228" target="_blank"&gt;launched on iOS&lt;/a&gt; using &lt;a href="https://www.cocoon.io" target="_blank"&gt;Cocoon.io&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;Test game: &lt;a href="http://www.mariocraft.club" target="_blank"&gt;Mariocraft&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;Advanced: &lt;a href="super-mario-bros/index.html" target="_blank"&gt;Super Mario Bros, level 1-1&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;Elementary: &lt;a href="ball/index.html" target="_blank"&gt;Bouncing ball&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;Basic: &lt;a href="mario/index.html" target="_blank"&gt;Mario in an empty world&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;Basic: &lt;a href="gui/index.html" target="_blank"&gt;GUI&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;Basic: &lt;a href="frog/index.html" target="_blank"&gt;Hoppy frog&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;
        These examples are on &lt;a href="https://github.com/martindrapeau/backbone-game-engine"&gt;Github&lt;/a&gt;.
      &lt;/p&gt;
    &lt;/div&gt;
    &lt;div class="col-md-3 col-xs-6"&gt;
      &lt;p&gt;
        &lt;div class="carousel slide" data-ride="carousel"&gt;
          &lt;div class="carousel-inner"&gt;
              &lt;a class="item active" href="super-mario-bros/index.html" target="_blank"&gt;
                &lt;img src="docs/super-mario-bros-level-1-1.png" alt="" class="img-responsive" alt="Super Mario Bros level 1-1" title="Super Mario Bros level 1-1" /&gt;
                &lt;span class="carousel-caption"&gt;Click to play&lt;/span&gt;
              &lt;/a&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h4&gt;CocoonJS Example&lt;/h4&gt;
      &lt;p&gt;
        Backbone Game Engine was written to run inside of CocoonJS Canvas+, so you can turn your HTML5 game into a native application on iOS or Android. If you have the CocoonJS launcher loaded on your iOS or Android device, you can load Super Mario Bros level 1-1 via this URL:
      &lt;/p&gt;
</code></pre>

<pre>
http://martindrapeau.github.io/cocoon-mario/cocoon-mario.zip
</pre>

<pre><code>    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div id="features" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3&gt;Features:&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;strong&gt;Built on Backbone&lt;/strong&gt;. Events, models, collections, inheritance and RESTful persistence. Why reinvent the wheel?&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;HTML5 canvas only&lt;/strong&gt;. No jQuery, as little DOM manipulations as possible.&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;Mobile optimized&lt;/strong&gt;. Build to run on mobile devices with transparent touch and viewport support. Everything is optimized for maxium frames per seconds (FPS).&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;Go Native with CocoonJS.&lt;/strong&gt;. Built to run in Ludei's &lt;a href="http://support.ludei.com/hc/en-us/articles/200767118-Canvas-development-Guide" target="_blank"&gt;CocoonJS canvas+&lt;/a&gt;. Deploy native on iOS and Android.&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;2D platformer&lt;/strong&gt;. Built with side-scrollers in mind. Built-in classes for sprites, sprite sheets, characters, hero, quad-tree collision detection, world and editor.&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;No compilation&lt;/strong&gt;. You don't need to install node, grunt or whatever else. Just code and press F5 to run.&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;No server required&lt;/strong&gt;. Fork this repo and your Github site is up and going. Create your own game and point your friends to it. Rebase to pull in latest engine updates.&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;Built for mobile&lt;/strong&gt;. Conceived to run on tablets. Share your URL with Mom so she can add it to the home screen of her iPad.&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;Take if offline&lt;/strong&gt;. With HTML5 Application Cache, your game runs offline. Perfect for taking it on the road or on a fishing trip.&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;Save state&lt;/strong&gt;. With HTML5 Local Storage, save where you are.&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;World editor&lt;/strong&gt;. Conceived for tile-based games, comes with a world editor. Place your tiles and characters, then hit play to try it out. Hit save to save your world.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div id="dependencies" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3&gt;Dependencies&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href="http://underscorejs.org/" target="_blank"&gt;Underscore&lt;/a&gt; &lt;/li&gt;
        &lt;li&gt;&lt;a href="http://backbonejs.org/" target="_blank"&gt;Backbone&lt;/a&gt; &lt;/li&gt;
        &lt;li&gt;&lt;a href="https://github.com/inkling/backbone.native/" target="_blank"&gt;backbone.native&lt;/a&gt;. To drop jQuery.&lt;/li&gt;
        &lt;li&gt;&lt;a href="https://github.com/asaarinen/qtree/" target="_blank"&gt;simple-quadtree&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;
        All included in the &lt;code&gt;3rd&lt;/code&gt; folder.  That and nothing else.
      &lt;/p&gt;

      &lt;h3&gt;Why Backbone?&lt;/h3&gt;
      &lt;p&gt;
        Backbone implements &lt;a href="http://backbonejs.org/#Events" target="_blank"&gt;events&lt;/a&gt;, &lt;a href="http://backbonejs.org/#Model" target="_blank"&gt;models&lt;/a&gt;, &lt;a href="http://backbonejs.org/#Collection" target="_blank"&gt;collections&lt;/a&gt;, &lt;a href="http://backbonejs.org/#Model-extend" target="_blank"&gt;inheritance&lt;/a&gt; and &lt;a href="http://backbonejs.org/#Sync" target="_blank"&gt;persistence&lt;/a&gt;. Models implement getters and setters for object attributes. Models and Collections have an &lt;code&gt;extend&lt;/code&gt; function to easily do inheritance. They implement methods for persistence (RESTful JSON by default). They can also trigger events and bind to them. Everything you need to build a great extensible game engine. Plus, Backbone is now widely used and provides these features in a standard fashion with a huge community to support them. I hope this project can make game programming accessible to developers already familiar with Backbone.
      &lt;/p&gt;

      &lt;h3&gt;Using and Contributing&lt;/h3&gt;
      &lt;p&gt;
        Backbone Game Engine was built to get you going fast. &lt;a href="https://github.com/martindrapeau/backbone-game-engine"&gt;Fork this repository&lt;/a&gt;, and your own Github page will be ready in minutes. You can then create your own games by simply creating a new directory, and putting files in it.
      &lt;/p&gt;
      &lt;p&gt;
        The default branch is &lt;code&gt;gh-pages&lt;/code&gt; so that any changes get published automatically to the Github page. Changes typically take only a few seconds to get published. This allows you to develop, test, document and deploy rapidly. It is a double-edge sword though. Any untested code you push to your fork on that branch will be felt by your users. It is therefore a good practice to create and work on another branch, and fast-forward merge to the &lt;code&gt;gh-pages&lt;/code&gt; branch when done.
      &lt;/p&gt;
      &lt;p&gt;
        To report a bug, use &lt;a href="https://github.com/martindrapeau/backbone-game-engine/issues" target="_blank"&gt;Github issues&lt;/a&gt;. To contribute improvements, bug fixes or new examples, make changes to your fork and do a pull request. For anyone looking to help, here is a short to-do list:
      &lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;Implement vertical panning in Backbone.Camera.&lt;/li&gt;
        &lt;li&gt;Revamp collision detection: optimize lookup and better functions.&lt;/li&gt;
        &lt;li&gt;Implement sound.&lt;/li&gt;
        &lt;li&gt;Add missing behaviors in Super Mario: character death, break brick, etc.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;br/&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- Documentation --&gt;
  &lt;div id="getting-started" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h1&gt;Getting Started&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div id="documentation-Backbone" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3&gt;Backbone&lt;/h3&gt;
      &lt;p&gt;
        The engine is based on Backbone so it is essential to understand its core structure: a &lt;a href="http://backbonejs.org/#Model" target="_blank"&gt;Backbone.Model&lt;/a&gt;. A model has hash of &lt;code&gt;attributes&lt;/code&gt; that are changed via getter and setter methods &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;. These attributes should only contain state information as it is those attributes which get saved and restored. A model is a Javascript object. Hence behaviour can be stored as properties and methods directly on the object. For example a sprite sheet points to an image. Attribute &lt;code&gt;img&lt;/code&gt; contains the &lt;code&gt;Image&lt;/code&gt; object or DOM selector (by id) for retrieving the Image object. Property &lt;code&gt;img&lt;/code&gt; contains reference to the Image object. It is automatically set when the sprite sheet model is initialized.
        &lt;pre&gt;
</code></pre>

<p>var spriteSheet = new Backbone.SpriteSheet({
  id: "mario",
  img: "#mario",
  tileWidth: 32,
  tileHeight: 64,
  tileColumns: 21,
  tileRows: 6
});
spriteSheet.get("img"); // attribute
// #mario</p>

<p>spriteSheet.img; // property
// &lt;img id=​"mario" src=​"../​super-mario-bros/​super-mario-2x.png" style=​"display:​none;​"&gt;</p>

<p>spriteSheet.img.width
//672</p>

<p>spriteSheet.img.height
//384

          </p>
          <p>
            In fact, a model stores its attributes in the object property <code>attributes</code>. Methods <code>get</code>, <code>set</code> and <code>toJSON</code> operate on that property. Just remember that state date like sprite coordinates, velocity, etc go in there. However references to other objects do not.
          </p>
          <div>
            Note on nomenclature: The word <strong>attribute</strong> is used to define state data (get and set stored in obejct property attributes) while the word <strong>property</strong> is used to define behavioural data stored directly on the object.
          </div>
        
      

<pre><code>  &lt;div class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3 id="documentation-no-jQuery"&gt;Living without jQuery&lt;/h3&gt;
      &lt;p&gt;
        Backbone Game Engine does not use jQuery. Instead, it depends on &lt;a href="https://github.com/inkling/backbone.native/" target="_blank"&gt;backbone.native&lt;/a&gt; which re-creates the ubiquitous &lt;code&gt;$&lt;/code&gt; function/object with only essentials required by Backbone. As such, you are limited to simple DOM selectors enabled by &lt;a href="https://developer.mozilla.org/en/docs/Web/API/Document.querySelectorAll" target="_blank"&gt;querySelectorAll&lt;/a&gt; and events. Since the framework is for canvas-based games, avoid HTML manipulations. Canvas-based only allows for easier wrapping with CocoonJS. Consult the documentation of backbone.native to understand limitations.
      &lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3 id="documentation-Structure"&gt;Directory structure&lt;/h3&gt;
      &lt;p&gt;
        To create a new example (or game), create an empty directory at the same level as &lt;code&gt;super-mario-bros&lt;/code&gt;. Then, add some files. Here is the recommended file structure:
      &lt;/p&gt;
      &lt;pre&gt;
</code></pre>

<p>3rd/
src/
...
super-mario-bros/
my-game/
        index.html
        main.js

          </p><p>
            <code>index.html</code> is the HTML document which loads your assets, and defines your canvas. File <code>main.js</code> is where you instantiate the game engine and sprites. It must get loaded last.
          </p>

<pre><code>      &lt;h3 id="documentation-HTML"&gt;index.html&lt;/h3&gt;
      &lt;p&gt;
        The HTML document (usually named &lt;code&gt;index.html&lt;/code&gt; in its own folder) declares the assets to be loaded and the &lt;code&gt;canvas&lt;/code&gt; element. Javascript assets are declared in the &lt;code&gt;HEAD&lt;/code&gt; element. Images are loaded via &lt;code&gt;IMG&lt;/code&gt; elements. They must be hidden with inline CSS. Everything is bootstrap-loaded as declared in the HTML file. There is no asynchronous loading.
      &lt;/p&gt;
      &lt;p&gt;
        Here is an example HTML file taken from the example &lt;a href="mario/index.html" target="_blank"&gt;Mario&lt;/a&gt;.
      &lt;/p&gt;
      &lt;pre&gt;
</code></pre>

<p>&lt;!doctype html&gt;
&lt;html style="touch-action: none;"&gt;
    &lt;head&gt;
        &lt;title&gt;Mario - Backbone Game Engine&lt;/title&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
        &lt;link href="../favicon.ico" rel="shortcut icon" type="image/x-icon" /&gt;
        &lt;link href="../apple_touch_icon.png" rel="apple-touch-icon" /&gt;</p>

<pre><code>    &amp;lt;meta name="viewport" content="width=960, user-scalable=no"/&amp;gt;
    &amp;lt;meta name="apple-mobile-web-app-capable" content="yes" /&amp;gt;
    &amp;lt;meta name="mobile-web-app-capable" content="yes" /&amp;gt;
    &amp;lt;meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/&amp;gt;

    &amp;lt;script src="../3rd/underscore.js" type="text/javascript"&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src="../3rd/backbone.native.js" type="text/javascript"&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src="../3rd/backbone.js" type="text/javascript"&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;script src="../src/shapes.js" type="text/javascript"&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src="../src/core.js" type="text/javascript"&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src="../src/input.js" type="text/javascript"&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src="../src/hero.js" type="text/javascript"&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src="../src/world.js" type="text/javascript"&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;script src="main.js" type="text/javascript"&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;style&amp;gt;
        body {
            margin: 0;
            background-color: #000;
        }
        canvas {
            position: fixed;
            top: 0;
            left: 0;
        }
    &amp;lt;/style&amp;gt;

&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;img id="mario" src="../super-mario-bros/super-mario-2x.png" style="display:none;" /&amp;gt;
    &amp;lt;canvas id="foreground" width="960" height="700"&amp;gt;
        Your browser does not support canvas element.
    &amp;lt;/canvas&amp;gt;
&amp;lt;/body&amp;gt;
</code></pre>

<p>&lt;/html&gt;

          </p><p>
            Some important notes:
          </p>
          <ul>
            <li>HTML meta tags <code>viewport</code>, <code>apple-mobile-web-app-capable</code>, <code>mobile-web-app-capable</code> and <code>apple-mobile-web-app-status-bar-style</code> ensure the canvas is properly sized and styled on iPads and other mobile devices. The width specified there should be the same as the canvas elements. On <a href="#mobile-devices">mobile devices</a>, an orientation change will recalculate and change the width to fit the canvas in the viewport. </li>
            <li>Style <code>touch-action: none;</code> on the <code>HTML</code> tag disables touch behaviors, like pan and zoom for IE10.</li>
            <li>Elements must all have ids since we use the native <code>getElementById</code> Javascript function to retrieve the <code>Canvas</code> and <code>Image</code> objects from their respective DOM elements.</li>
          </ul>

<pre><code>      &lt;h3 id="documentation-main"&gt;main.js&lt;/h3&gt;
      &lt;p&gt;
        File &lt;code&gt;main.js&lt;/code&gt; is where you declare and initialize your objects. It is recommended that you wrap that code in a function which gets executed once the document and all assets are loaded (i.e. window.onload event). You can use for example &lt;code&gt;$(window).on("load", function() {});&lt;/code&gt;. 
      &lt;/p&gt;
      &lt;p&gt;
        Other files use a simple anonymous function instead since they contain class declarations mainly. However in &lt;code&gt;main.js&lt;/code&gt; is where &lt;code&gt;Canvas&lt;/code&gt; and &lt;code&gt;Image&lt;/code&gt; objects are retrieved from the DOM elements. So they must first be loaded. This keeps things simple. Assets are as a consequence always loaded synchronously.
      &lt;/p&gt;
      &lt;p&gt;
        Here is a sample &lt;code&gt;main.js&lt;/code&gt; file, taken from the &lt;a href="mario/index.html" target="_blank"&gt;Mario&lt;/a&gt; example.
      &lt;/p&gt;
      &lt;pre&gt;
</code></pre>

<p>$(window).on("load", function() {</p>

<p>// Mario alone in an empty world. Control him with the touchpad.</p>

<p>Backbone.Mario = Backbone.Hero.extend({
    defaults: _.extend({}, Backbone.Hero.prototype.defaults, {
      name: "mario",
      spriteSheet: "mario"
    })
  });</p>

<p>var canvas = document.getElementById("foreground");</p>

<p>var spriteSheets = new Backbone.SpriteSheetCollection([{
    id: "mario",
    img: "#mario",
    tileWidth: 32,
    tileHeight: 64,
    tileColumns: 21,
    tileRows: 6
  }]).attachToSpriteClasses();</p>

<p>var debugPanel = new Backbone.DebugPanel();</p>

<p>var input = new Backbone.Input({
    drawTouchpad: true,
    drawPause: true
  });</p>

<p>var mario = new Backbone.Mario({
    x: 400, y: 400, floor: 500
  }, {
    input: input
  });</p>

<p>var world = new Backbone.World({
    width: 30, height: 18,
    tileWidth: 32, tileHeight: 32,
    backgroundColor: "rgba(66, 66, 255, 1)",
    viewportBottom: 156
  });
  world.add(mario);</p>

<p>var engine = new Backbone.Engine({}, {
    canvas: canvas,
    debugPanel: this.debugPanel,
    input: input
  });
  engine.add([
    world,
    input,
    debugPanel
  ]);</p>

<p>// Expose things as globals - easier to debug
  _.extend(window, {
    canvas: canvas,
    engine: engine
  });</p>

<p>// Ensure the canvas is always visible and centered
  adjustViewport(canvas, canvas.width, canvas.height);</p>

<p>});

        
      </p>

<pre><code>  &lt;div id="documentation" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h1&gt;Reference&lt;/h1&gt;
      &lt;p&gt;
        Backbone Game Engine defines classes in the &lt;code&gt;Backbone&lt;/code&gt; namespace. Most are sub-classed from &lt;code&gt;Backbone.Model&lt;/code&gt; or &lt;code&gt;Backbone.Collection&lt;/code&gt;.
      &lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div id="documentation-Engine" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3&gt;Backbone.Engine&lt;/h3&gt;
      &lt;pre&gt;new Backbone.Engine([attributes], [options])&lt;/pre&gt;
      &lt;p&gt;
        &lt;code&gt;Backbone.Engine&lt;/code&gt; is a Backbone model that holds a &lt;a href="http://backbonejs.org/#Collection" target="_blank"&gt;Backbone collection&lt;/a&gt; of sprite models.
        It uses HTML5's &lt;a href="https://developer.mozilla.org/en/docs/Web/API/window.requestAnimationFrame" target="_blank"&gt;requestAnimationFrame&lt;/a&gt; to provide a 60 frames per second game loop.
      &lt;/p&gt;
      &lt;p&gt;
        The sprite collection is stored in property &lt;code&gt;sprites&lt;/code&gt;. You may directly access it however for convenience, methods &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt; exist as proxy the engine.
      &lt;/p&gt;
      &lt;h4&gt;Attributes&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;clearOnDraw&lt;/code&gt;: Optional. Boolean to ask for a clear of the canvas before redraw. Defaults to false. Note that this is an expensive call. Better to only clear the area that changed.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;tapDetectionDelay&lt;/code&gt;: Optional. The delay in ms before a tap gestured is detected. Defaults to 50ms&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;tapMoveTolerance&lt;/code&gt;: Optional. The amount of pixel move tolerated to detect a tap gesture. Defaults to +/-5 pixels. Beyond that, a drag gesture will be trigerred.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Options&lt;/h4&gt;
      &lt;p&gt;
        Upon instantiation, these options can be passed. They will be stored as properties on the &lt;code&gt;Backbone.Engine&lt;/code&gt; model instance.
      &lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;canvas&lt;/code&gt;: The canvas to draw upon. Drawing is on its 2d context.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;input&lt;/code&gt;: Optional. The user control input instance. If passed and the pause button is enabled, will stop/start then engine when pressed.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;debugPanel&lt;/code&gt;: Optional. A &lt;a href="#documentation-DebugPanel"&gt;Backbone.DebugPanel&lt;/a&gt; instance. If passed &lt;code&gt;fps&lt;/code&gt; and &lt;code&gt;cycleTime&lt;/code&gt; are output.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Methods&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;add()&lt;/code&gt;: Adds one or multiple models delegating to the sprite collection's &lt;code&gt;add&lt;/code&gt; method.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;remove()&lt;/code&gt;: Removes one or multiple models delegating to the sprite collection's &lt;code&gt;remove&lt;/code&gt; method.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;reset()&lt;/code&gt;: Clears or sets the sprites collection delegating to the &lt;code&gt;reset&lt;/code&gt; method.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;isRunning()&lt;/code&gt;: Returns true if the engine is running, or false if not.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;start(), stop()&lt;/code&gt;: Starts or stops the engine.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;toggle()&lt;/code&gt;: Toggle start/stop the engine.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Events&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;tap&lt;/code&gt;: Trigerred when the user clicks or taps on the canvas. A tap is defined when the user presses/clicks on a position without moving for more than &lt;code&gt;tapDetectionDelay&lt;/code&gt; ms. The event callback function is passed the DOM event object, with these extra properties attached: &lt;code&gt;canvas&lt;/code&gt;, &lt;code&gt;canvasX&lt;/code&gt; and &lt;code&gt;canvasY&lt;/code&gt;. In addition, property &lt;code&gt;canvasHandled&lt;/code&gt; is provided as a mechanism to stop propagation (see below). &lt;/li&gt;
        &lt;li&gt;&lt;code&gt;key&lt;/code&gt;: Trigerred when the user types in a key. The event callback function is passed the DOM event object, with additional property &lt;code&gt;canvas&lt;/code&gt;.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;dragstart&lt;/code&gt;, &lt;code&gt;dragmove&lt;/code&gt; and &lt;code&gt;dragend&lt;/code&gt;: Trigerred when a drag gesture occurs. This happens when the user presses/clicks and holds and moves. When these events are trigerred, the &lt;code&gt;tap&lt;/code&gt; event does not get trigerred.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class="alert alert-info"&gt;
        Note: The &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;drag*&lt;/code&gt; events are broadcasted to whomever is listening. Event property &lt;code&gt;canvasHandled&lt;/code&gt; is used to to prevent propagation to many overlapping objects. At first it is set to &lt;code&gt;false&lt;/code&gt;. The first object to intercept and handle the event should set it to &lt;code&gt;true&lt;/code&gt;. Subsequent objects intercepting the event should look at this property and return without action when &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;Backbone.Button&lt;/code&gt; and &lt;code&gt;Backbone.WorldEditor&lt;/code&gt; implement this behavior.
      &lt;/div&gt;
      &lt;h4&gt;How it works&lt;/h4&gt;
      &lt;p&gt;During every animation frame, the engine performs these things:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;Loop through models (in order), and calls their &lt;code&gt;update&lt;/code&gt; method. Passing &lt;code&gt;dt&lt;/code&gt;, the time in milliseconds since the last call to update. The update method must return &lt;code&gt;true&lt;/code&gt; to ask for a redraw, or &lt;code&gt;false&lt;/code&gt; not to.&lt;/li&gt;
        &lt;li&gt;Loop through all models that requested a redraw, and call their &lt;code&gt;draw&lt;/code&gt; method passing &lt;code&gt;context&lt;/code&gt;, the canvas 2d context. Perform whatever magic you like in the draw method.&lt;/li&gt;
        &lt;li&gt;Call itself again upon the next animation frame.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class="alert alert-info"&gt;Note: By default the engine does not clear the canvas before redraw. You can set the &lt;code&gt;clearOnDraw&lt;/code&gt; option to do so however it is an expensive call. Better to do it only when required. See class &lt;a href="#documentation-World"&gt;Backbone.World&lt;/a&gt; for an example.&lt;/div&gt;
      &lt;p&gt;
        The &lt;code&gt;update&lt;/code&gt; method is used to update the model position, animation, detect collisions, or whatever you like. If it requests a redraw, the engine will then call its &lt;code&gt;draw&lt;/code&gt; method. The engine ensures that models are updated and drawn in the order they are sorted in the collection. You can define the sort order by defining a &lt;a href="http://backbonejs.org/#Collection-comparator" target="_blank"&gt;comparator&lt;/a&gt;.
      &lt;/p&gt;
      &lt;p&gt;
        Models added to the collection receive an &lt;code&gt;attach&lt;/code&gt; event and have property &lt;code&gt;engine&lt;/code&gt; set as backreference. When removed, they receive a &lt;code&gt;detach&lt;/code&gt; event.
      &lt;/p&gt;
      &lt;p&gt;
        To measure performance, two properties are set: &lt;code&gt;fps&lt;/code&gt; and &lt;code&gt;cycleTime&lt;/code&gt;. If you passed option &lt;code&gt;debugPanel&lt;/code&gt;, they will be drawn on screen.
      &lt;/p&gt;
      &lt;p&gt;
        The engine can be started and stopped. When running, will perform an update/draw sequence 60 times per second. Use methods &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt; or &lt;code&gt;toggle&lt;/code&gt;. Use method &lt;code&gt;isRunning&lt;/code&gt; to determine if the engine is running. If you passed option &lt;code&gt;input&lt;/code&gt;, the engine will bind to the &lt;em&gt;pause&lt;/em&gt; button (or the &lt;em&gt;p&lt;/em&gt; key) to toggle start/stop.
      &lt;/p&gt;
      &lt;h4&gt;Usage&lt;/h4&gt;
      &lt;pre&gt;
</code></pre>

<p>var canvas = document.getElementById("foreground");</p>

<p>var debugPanel = new Backbone.DebugPanel();</p>

<p>var ball = new Backbone.Ball({
    x: 100, y: 100, color: "blue"
  });</p>

<p>var engine = new Backbone.Engine({
    clearOnDraw: true
  }, {
    canvas: canvas,
    debugPanel: debugPanel
  });
  engine.add([
    ball,
    debugPanel
  ]);

          </p><p>
            Taken from the <a href="ball/index.html" target="_blank">Bouncing Ball</a> example. Draws two models: the debug panel and a bouncing ball.
          </p>
        
      

<pre><code>  &lt;div id="documentation-SpriteSheet" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3&gt;Backbone.SpriteSheet&lt;/h3&gt;
      &lt;pre&gt;new Backbone.SpriteSheet([attributes], [options]);&lt;/pre&gt;
      &lt;p&gt;
        &lt;code&gt;Backbone.SpriteSheet&lt;/code&gt; is a Backbone model which breaks an image into frames used for animation.
      &lt;/p&gt;
      &lt;h4&gt;Attributes&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;img&lt;/code&gt;: The &lt;code&gt;Image&lt;/code&gt; object or element id selector of the image to find in the DOM (i.e. &lt;code&gt;#icons&lt;/code&gt;). A pointer to the Image object is then stored in property &lt;code&gt;img&lt;/code&gt;.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;tileWidth, tileHeight&lt;/code&gt;: Size of tiles in pixels.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;tileColumns, tileRows&lt;/code&gt;: Number of tiles in the image.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Properties&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;frames&lt;/code&gt;: Array of animation frames. Automatically set when model is instantiated.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;img&lt;/code&gt;: Pointer to &lt;code&gt;Image&lt;/code&gt; object. Automatically set when model is instantiated.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;
        When a sprite sheet is instantiated, an array of frames is built and stored in property &lt;code&gt;frames&lt;/code&gt;. A frame object contains the coordinates of the frame. It consists of &lt;code&gt;{x, y, width, height}&lt;/code&gt; representing the pixel position and size of the frame. These will be passed to the &lt;a href="https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D#drawImage()" target="_blank"&gt;HTML5 canvas drawImage&lt;/a&gt; function as arguments &lt;code&gt;sx, sy, sw, sh&lt;/code&gt; by the &lt;code&gt;draw&lt;/code&gt; method.
      &lt;/p&gt;
      &lt;p&gt;
        Sprite sheets are not generally created on their own, but rather in a &lt;code&gt;Backbone.SpriteSheetCollection&lt;/code&gt;. See below for usage.
      &lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div id="documentation-SpriteSheetCollection" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3&gt;Backbone.SpriteSheetCollection&lt;/h3&gt;
      &lt;pre&gt;new Backbone.SpriteSheetCollection([models], [options]);&lt;/pre&gt;
      &lt;p&gt;
        &lt;code&gt;Backbone.SpriteSheetCollection&lt;/code&gt; is a Backbone collection of &lt;code&gt;Backbone.SpriteSheet&lt;/code&gt; models.
      &lt;/p&gt;
      &lt;h4&gt;Methods&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;attachToSpriteClasses()&lt;/code&gt;: Attaches sprite sheets to sprite class prototypes. Does so by finding all defined sprite classes (&lt;code&gt;Backbone.*&lt;/code&gt;) with default attribute &lt;code&gt;spriteSheet&lt;/code&gt; matching a sprite sheet id in the collection. Then sets their &lt;code&gt;spriteSheet&lt;/code&gt; property to point to the correct sprite sheet in the collection.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Usage&lt;/h4&gt;
      &lt;p&gt;
        Define your sprite sheets by creating a collection as such:
      &lt;/p&gt;
      &lt;pre&gt;
</code></pre>

<p>this.spriteSheets = new Backbone.SpriteSheetCollection([{
  id: "mario",
  img: "#mario",
  tileWidth: 32,
  tileHeight: 64,
  tileColumns: 21,
  tileRows: 2
}, {
  id: "tiles",
  img: "#tiles",
  tileWidth: 32,
  tileHeight: 32,
  tileColumns: 29,
  tileRows: 28
}]).attachToSpriteClasses();

          </p><p>
            <img src="docs/super-mario-sprite.png" alt="Backbone.Input">
          </p>
          <p>
            Here two sprite sheets are created <code>mario</code> and <code>tiles</code>. Their graphics are in <code>Image</code> objects found in the DOM. The attribute <code>img</code> is the selector to retrieve them.
          </p>
          <p>
            Calling method <code>attachToSpriteClasses</code> will attach the sprite sheets to each sprite class found in the <code>Backbone</code> namespace.
          </p>
        
      

<pre><code>  &lt;div id="documentation-Sprite" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3&gt;Backbone.Sprite&lt;/h3&gt;
      &lt;pre&gt;new Backbone.Sprite([attributes], [options]);&lt;/pre&gt;
      &lt;p&gt;
        &lt;code&gt;Backbone.Sprite&lt;/code&gt; is a &lt;a href="http://backbonejs.org/#Model" target="_blank"&gt;Backbone Model&lt;/a&gt; which implements the required &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;draw&lt;/code&gt; methods to animate a sprite, frame by frame.
      &lt;/p&gt;
      &lt;h4&gt;Attributes&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;x, y&lt;/code&gt;: The coordinates in pixels.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;width, height&lt;/code&gt;: Size of the sprite in pixels.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;paddingLeft, paddingRight, paddingTop, paddingBottom&lt;/code&gt;: Optional. Internal padding to account for empty space inside the tile of a sprite. Useful to specify empty zones for collision detection.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;sequenceIndex&lt;/code&gt;: The current animation sequence frame. Automatically set.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;state&lt;/code&gt;: The current animation.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;spriteSheet&lt;/code&gt;: Sprite sheet id. &lt;/li&gt;
        &lt;li&gt;&lt;code&gt;collision&lt;/code&gt;: Optional. For use with &lt;a href="#documentation-World"&gt;Backbone.World&lt;/a&gt;.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;static&lt;/code&gt;: Optional. For use with &lt;a href="#documentation-World"&gt;Backbone.World&lt;/a&gt;.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;visible&lt;/code&gt;: Optional boolean. If true, the sprite is not drawn. Default is false.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;zIndex&lt;/code&gt;: Optional. Specifies the drawing order. Higher value is drawn above sprites with lower values. Default is 0.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class="alert alert-info"&gt;
        Note: &lt;code&gt;zIndex&lt;/code&gt; is only used in &lt;code&gt;Backbone.World&lt;/code&gt;. Currently, it is partially implemented - only 0 and 1 values are recognized.
      &lt;/div&gt;
      &lt;h4&gt;Properties&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;animations&lt;/code&gt;: Hash of animations of the sprite. Described further below.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;spriteSheet&lt;/code&gt;: Instance of the &lt;code&gt;Backbone.SpriteSheet&lt;/code&gt; holding the images to animate. This is automatically set when you define your sprite sheet collection. See &lt;a href="#documentation-SpriteSheetCollection"&gt;Backbone.SpriteSheetCollection&lt;/a&gt; for details.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;saveAttributes&lt;/code&gt;: Attributes serialized for persistence. Defaults to &lt;code&gt;["name", "state", "sequenceIndex", "x", "y"]&lt;/code&gt;.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Methods&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;toSave()&lt;/code&gt;: Serializes attributes for persistence. Attributes to be serialized are specified in the &lt;code&gt;saveAttributes&lt;/code&gt; property.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;update(dt)&lt;/code&gt;: Called by then engine 60 times a second. Updates sprite attribues and implements behavior. Returns true to ask for a redraw, or false for none.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;onUpdate(dt)&lt;/code&gt;: Not defined by default. If you define it, it is called at the end of &lt;code&gt;update&lt;/code&gt;. Useful for extending the behavior of a sprite without having to overload metod &lt;code&gt;update&lt;/code&gt;. Note that &lt;code&gt;draw&lt;/code&gt; is called based on the Boolean return value of this method to decide whether to draw or not. It must therefore return &lt;code&gt;true&lt;/code&gt; to perform a draw, or &lt;code&gt;false&lt;/code&gt; not to.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;draw(context, options)&lt;/code&gt;: Called by the engine after &lt;code&gt;update&lt;/code&gt;, if a redraw was asked. Takes care of rendering the sprite, and its proper animation at the correct position. Argument &lt;code&gt;options&lt;/code&gt; can be used by a model serving as proxy. For example it is passed when drawn by a &lt;code&gt;Backbone.World&lt;/code&gt;instance. It will contain &lt;code&gt;offsetX&lt;/code&gt; and &lt;code&gt;offsetY&lt;/code&gt; to transform &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; from world coordinates to canvas coordinates.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;onDraw(context, options)&lt;/code&gt;: Not defined by default. If defined, it is called at the end of &lt;code&gt;draw&lt;/code&gt;. Useful for extending the rendering of a sprite without having to overload metod &lt;code&gt;draw&lt;/code&gt;.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;getAnimation([state])&lt;/code&gt;: Returns the current animation based on argument &lt;code&gt;state&lt;/code&gt;. If argument &lt;code&gt;state&lt;/code&gt; is omitted, the attribute is used instead.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;overlaps(x, y):&lt;/code&gt;: Checks to see if the sprite overlaps with the passed coordinates. Returns a Boolean.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;getLeft(withPadding), getRight(withPadding), getTop(withPadding), getBotttom(withPadding)&lt;/code&gt;: Returns the left, right, top or bottom-most position of a sprite. Argument withPadding is a boolean specifying whether to include the padding or not. Defaults to false.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;bbox(withPadding)&lt;/code&gt;: Returns the bounding box of the sprite as an object &lt;code&gt;{x1, y1, x2, y2}&lt;/code&gt;. Argument &lt;code&gt;withPadding&lt;/code&gt; is a boolean specifying whether to include the padding or not. Defaults to false.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;getCenterX(withPadding)&lt;/code&gt;: Returns the center &lt;code&gt;x&lt;/code&gt; of the sprite. Argument &lt;code&gt;withPadding&lt;/code&gt; is a boolean specifying whether to include the padding or not. Defaults to false.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;getCenterX(withPadding)&lt;/code&gt;: Returns the center &lt;code&gt;y&lt;/code&gt; of the sprite. Argument &lt;code&gt;withPadding&lt;/code&gt; is a boolean specifying whether to include the padding or not. Defaults to false.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Events&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;attach&lt;/code&gt;: Triggered when the sprite is attached to the engine.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;detach&lt;/code&gt;: Triggered when the sprite is detached to the engine.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;
        The &lt;code&gt;attach&lt;/code&gt; and &lt;code&gt;detach&lt;/code&gt; events can be used to start/stop listening to events. For example, the &lt;code&gt;Backbone.Hero&lt;/code&gt; sprite starts listening to user input when attached, and stops when detached.
      &lt;/p&gt;
      &lt;h4&gt;Sprite and sprite sheets&lt;/h4&gt;
      &lt;p&gt;
        Graphics are obtained from a &lt;a href="#documentation-SpriteSheet"&gt;Backbone.SpriteSheet&lt;/a&gt; model. In attribute &lt;code&gt;spriteSheet&lt;/code&gt;, specify the sprite sheet id you previously defined in a &lt;code&gt;Backbone.SpriteSheetCollection&lt;/code&gt; instance. The collection will automatically attach it to the sprite by setting property &lt;code&gt;spriteSheet&lt;/code&gt; as back reference. Building on the example above:
      &lt;/p&gt;
      &lt;pre&gt;
</code></pre>

<p>var spriteSheets = new Backbone.SpriteSheetCollection([{
  id: "mario",
  img: "#mario",
  tileWidth: 32,
  tileHeight: 64,
  tileColumns: 21,
  tileRows: 2
}]).attachToSpriteClasses();</p>

<p>var mario = new Backbone.Mario({
  spriteSheet: "mario"
});</p>

<p>mario.get("spriteSheet");
// mario</p>

<p>spriteSheets.get("mario");
// child {cid: "c2", attributes: Object, collection: child, _changing: false, _previousAttributes: Object…}</p>

<p>mario.spriteSheet;
// child {cid: "c2", attributes: Object, collection: child, <em>changing: false, _previousAttributes: Object…}

          <h4>
<a id="inheritance" class="anchor" href="#inheritance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Inheritance</h4>
          <p>
            Instantiating a <code>Backbone.Sprite</code> model is not very useful by itself. You must first extend the <code>Backbone.Sprite</code> class to provide your own animations and a pointer to the sprite sheet. For example this defines a sprite with 3 animations <code>idle</code>, <code>walk-left</code> and <code>walk-right</code>. It points to the sprite sheet id <code>mario</code>.
          </p>
          <pre>
Backbone.MySprite = Backbone.Sprite.extend({
  defaults: _.extend(</pre></em>.deepClone(Backbone.Sprite.prototype.defaults), {
    x: 400,
    y: 400,
    spriteSheet: "mario",
    state: "idle",
    sequenceIndex: 0,
    static: false,
    collision: true
  }),
  animations: {
    idle: {
      sequences: [0]
    },
    "walk-right": {
      sequences: [1, 2, 3, 2],
      delay: 200
    },
    "walk-left": {
      sequences: [1, 2, 3, 2],
      scaleX: -1,
      delay: 200
    }
  }
});
</p>

<pre><code>      &lt;p&gt;
        Above, the &lt;code&gt;Backbone.Sprite&lt;/code&gt; was sub-classed using &lt;code&gt;extend&lt;/code&gt; method. &lt;code&gt;defaults&lt;/code&gt; are the default attributes to give any new &lt;code&gt;Backbone.MySprite&lt;/code&gt; instance. They extend the Sprite class' defaults.
      &lt;/p&gt;
      &lt;p&gt;
        If you want to reuse parts of &lt;code&gt;defaults&lt;/code&gt; or &lt;code&gt;animations&lt;/code&gt; from a parent class, make sure to make a copy. You can use the helper function &lt;code&gt;_.deepClone&lt;/code&gt; for that purpose (&lt;code&gt;_.clone&lt;/code&gt; only goes one level deep). Otherwise you may change the parent class behavior. For example the &lt;code&gt;Backbone.PennieUg&lt;/code&gt; class reuses the &lt;code&gt;Backbone.Pennie&lt;/code&gt; class' properties &lt;code&gt;defaults&lt;/code&gt; and &lt;code&gt;animations&lt;/code&gt; by first creating copies.
      &lt;/p&gt;
      &lt;pre&gt;
</code></pre>

<p>Backbone.PennieUg = Backbone.Pennie.extend({
    defaults: <em>.extend(</em>.deepClone(Backbone.Pennie.prototype.defaults), {
      name: "pennie-ug"
    }),
    animations: _.deepClone(Backbone.Pennie.prototype.animations)
  });
  Backbone.PennieUg.prototype.animations.idle.sequences = [168, 168, 169, 170, 169, 168];

          </p><div>
            Helper function <code>deepClone</code> was created as a mixin of <code>underscore</code>. When it makes sense, make general functions available that way. Look at the end of <code>src/core.js</code> for all mixins.
          </div>
          <h4>
<a id="animations" class="anchor" href="#animations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Animations</h4>
          <p>
            Sprite property <code>animations</code> contains a hash of animations. Each animation contains a sequence of frames and a delay between frames for animation. For example:
          </p>
          <pre>
animations: {
  idle: {
    sequences: [0, 1],
    delay: 200
  }
}
</pre>
          <p>
            This defines an animation of two frames, alternating at an interval of 200ms. Values 0 and 1 in array <code>sequences</code> are frame indices defined in the sprite sheet. Sprite attributes <code>state</code> and <code>sequenceIndex</code> control which animation and sequence are currently used. The <code>sequenceIndex</code> is automatically incremented (and reset to 0) by the sprite's draw function. Attribute <code>state</code> determines the current animation. It must be set to <code>idle</code> in the above example (as there is only one).
          </p>
          <p>
            Extra animation options are available. Here is a complete list:
          </p>
          <ul>
            <li>
<code>sequences</code>: Array of frame indices, or squence objects. A sequence object looks like this: <code>{frame: 52, x: 0, y: -32, scaleX: 1.00, scaleY: 1}</code>. It allows you to specify an offset to apply when the sprite is drawn, and a scaling factor.</li>
            <li>
<code>scaleX, scaleY</code>: Optional. Scaling factors. Set <code>scaleX</code> to -1 to flip horizontally. Defaults to 1 if omitted.</li>
            <li>
<code>delay</code>: Optional. The time to change to the next sequence. No need to specify if there is only one frame (as there is no animation). You can also define a sprite method <code>sequenceDelay</code> to programmatically return the delay. It will be passed the current animation.</li>
          </ul>
          <p>
            For detailed examples of animations, look at file <code>artifacts.js</code> in the <code>super-mario-bros</code> folder. Class <code>Backbone.Pennie</code> implements a basic animation sequence using frame indices, while <code>Backbone.FlyingPennie</code> implements a more complex animation with sequence objects.
          </p>
          <pre>
Backbone.Pennie = Backbone.AnimatedTile.extend({
  ...
  animations: {
    idle: {
      sequences: [52, 52, 53, 54, 53, 52],
      delay: 50
    }
  },
  ...

<p>Backbone.FlyingPennie = Backbone.Sprite.extend({
  ...
  animations: {
    anim: {
      sequences: [
        {frame: 52, x: 0, y: -32, scaleX: 1.00, scaleY: 1},
        {frame: 52, x: 0, y: -64, scaleX: 0.50, scaleY: 1},
        {frame: 53, x: 0, y: -90, scaleX: 0.50, scaleY: 1},
        {frame: 53, x: 0, y: -128, scaleX: 1.00, scaleY: 1},
        {frame: 53, x: 0, y: -128, scaleX: 0.50, scaleY: 1},
        {frame: 52, x: 0, y: -112, scaleX: 0.50, scaleY: 1},
        {frame: 52, x: 0, y: -90, scaleX: 1.00, scaleY: 1},
        {frame: 52, x: 0, y: -80, scaleX: 0.50, scaleY: 1},
        {frame: 53, x: 0, y: -80, scaleX: 0.50, scaleY: 1}
      ],
      delay: 50
    }
  },
  ...</p>

<p></p></pre>
        
      

<pre><code>  &lt;div id="documentation-Input" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3&gt;Backbone.Input&lt;/h3&gt;
      &lt;pre&gt;new Backbone.Input([attributes], [options]);&lt;/pre&gt;
      &lt;p&gt;
        &lt;code&gt;Backbone.Input&lt;/code&gt; class is a model which captures user input events and stores them as model attributes. For example pressing the left arrow, sets the &lt;code&gt;left&lt;/code&gt; attribute to &lt;code&gt;true&lt;/code&gt;. Depressing sets it to &lt;code&gt;false&lt;/code&gt;. Bind to on the attribute change event to be notified.
      &lt;/p&gt;
      &lt;p&gt;
        &lt;code&gt;Backbone.Input&lt;/code&gt; supports keyboard, mouse and touch events. It can draw a touchpad on screen with left and right arrow keys, an A (red) button and a B (blue) button.
      &lt;/p&gt;
      &lt;p&gt;
        &lt;img src="docs/input.png" class="img-responsive" alt="Backbone.Input" /&gt;
      &lt;/p&gt;
      &lt;div class="alert alert-info"&gt;
        Note: The Backbone.Input model only captures input when attached to a Backbone.Engine.
      &lt;/div&gt;
      &lt;h4&gt;Attributes&lt;/h4&gt;
      &lt;p&gt;This attribute can be passed when creating the model, to configure the input.&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;drawTouchpad&lt;/code&gt;: Optional. Boolean or string "auto" to indicate whether to draw the touchpad. When "auto", the touchpad will be drawn only on touch devies. Defaults to "auto".&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;The following model attributes are set by the model. They should not be set externally.&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;touchEnabled&lt;/code&gt;: Boolean set to true if the device is touch enabled.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;left&lt;/code&gt;: Boolean set to true when the left touchpad arrow or left keyboard arrow key is pressed.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;right&lt;/code&gt;: Boolean set to true when the right touchpad arrow or right keyboard arrow key is pressed.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;buttonA&lt;/code&gt;: Boolean set to true when the A touchpad button is pressed, or when the z keyboard key is pressed.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;buttonB&lt;/code&gt;: Boolean set to true when the B touchpad button is pressed, or when the x keyboard key is pressed.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Methods&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;hasTouchpad()&lt;/code&gt;: Returns true if the touchpad is drawn.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;leftPressed()&lt;/code&gt;: Returns true if the left button is pressed.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;rightPressed()&lt;/code&gt;: Returns true if the right button is pressed.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;buttonAPressed()&lt;/code&gt;: Returns true if button A is pressed.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;buttonBPressed()&lt;/code&gt;: Returns true if button B is pressed.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Events&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;attach&lt;/code&gt;: Triggered when the input is attached to the engine. Will start listening to user input.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;detach&lt;/code&gt;: Triggered when the input is detached to the engine. Will stop listening to user input.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;
        You can add or remove a &lt;code&gt;Backbone.Input&lt;/code&gt; model from the engine on the fly. In the Super Mario Bros example, the &lt;code&gt;Backbone.Input&lt;/code&gt; and the &lt;code&gt;Backbone.WorldEditor&lt;/code&gt; are swapped when moving from play to edit modes.
      &lt;/p&gt;
      &lt;h4&gt;Usage&lt;/h4&gt;
      &lt;pre&gt;
</code></pre>

<p>var input = new Backbone.Input();
var engine = new Backbone.Engine();
engine.add(input);
input.bind("change:left", function(input) {
  if (input.leftPressed())
    console.log("left pressed:)");
  else
    console.log("left depressed:(");
});

        
      </p>

<pre><code>  &lt;div id="documentation-World" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3&gt;Backbone.World&lt;/h3&gt;
      &lt;pre&gt;new Backbone.World([attributes], [options])&lt;/pre&gt;
      &lt;p&gt;
        &lt;code&gt;Backbone.World&lt;/code&gt; is model which contains a collection of sprites that interact with each other. A world is an environment composed of tiles and characters. The world extends beyond the canvas however the viewport, the visible portion, is constrained within its prescribed limits. &lt;code&gt;Backbone.World&lt;/code&gt; is similar to a sprite; it implements the &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;draw&lt;/code&gt; methods required by the &lt;code&gt;Backbone.Engine&lt;/code&gt; collection.
      &lt;/p&gt;
      &lt;h4&gt;Attributes&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;x, y&lt;/code&gt;: Origin of top-left corner in pixels.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;width, height&lt;/code&gt;: Size of world in tiles.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;tileWidth, tileHeight&lt;/code&gt;: Size of a tile in pixels.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;viewportLeft, viewportRight, viewportTop, viewportBottom&lt;/code&gt;: Defines an area in the canvas the world is constrained to. Each value provides gutter regions in pixels. Anything drawn by the world will be clipped in the area. Useful for drawing a menu bar or buttons on the same canvas. In provided demos for example, &lt;code&gt;viewportBottom&lt;/code&gt; is set to 156 pixels to make room the the touchpad.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;sprites&lt;/code&gt;: Array of sprite models for persistence.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;backgroundColor&lt;/code&gt;: Background color of the world.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;backgroundImage&lt;/code&gt;: Id attribute of an image element in the DOM to show as background.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;state&lt;/code&gt;: Persisted state either play or pause.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class="alert alert-info"&gt;
        Note: Setting a viewport different than the canvas size uses canvas clipping. Avoid using if you can as clipping the is expensive and can introduce performance issues.
      &lt;/div&gt;
      &lt;h4&gt;Options&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;backgroundImage&lt;/code&gt;: Optional. Pass to use a background image instead of a background color. Anchored to the origin.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;input&lt;/code&gt;: Input instance to control the hero.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;camera&lt;/code&gt;: Camera instance to keep the hero in the viewport.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;debugPanel&lt;/code&gt;: Optional.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Methods&lt;/h4&gt;
      &lt;p&gt;
        A &lt;code&gt;Backbone.World&lt;/code&gt; is a model that wraps a collection stored in property &lt;code&gt;sprites&lt;/code&gt;. To prevent outside direct access to this collection, it provides these two methods:
      &lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;add(models, [options])&lt;/code&gt;: Add one or many models. Adds &lt;code&gt;world&lt;/code&gt; to options and delegates to the &lt;code&gt;sprites&lt;/code&gt; collection's &lt;code&gt;add&lt;/code&gt; method. Then sets the &lt;code&gt;world&lt;/code&gt; property as back-reference on the new model(s). Returns the new model(s).&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;remove(models, [options])&lt;/code&gt;: Removes one or many models. Delegates to the &lt;code&gt;sprites&lt;/code&gt; collection's &lt;code&gt;remove&lt;/code&gt; method. Deletes the &lt;code&gt;world&lt;/code&gt; back-reference and returns the model(s).&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;
        In addition to standard &lt;code&gt;Backbone.Model&lt;/code&gt; methods, it also exposes these:
      &lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;spawnSprites()&lt;/code&gt;: Resets the sprites collection by retrieving the &lt;code&gt;sprites&lt;/code&gt; attribute from the model. This is called after the world is loaded.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;update(dt)&lt;/code&gt;: Update function called by the engine. Will in turn call the update method of all sprites.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;draw(context)&lt;/code&gt;: Draw function called by the engine. Will in turn call the draw method of all sprites.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;cloneAtPosition(sprite, x, y)&lt;/code&gt;: Clones the sprite model and places the new instance at the specified coordinates. Will pass &lt;code&gt;world&lt;/code&gt; to the &lt;code&gt;options&lt;/code&gt; payload when created. Will also set property &lt;code&gt;world&lt;/code&gt; as back-reference. If the sprite name matches that of the world attribute &lt;code&gt;hero&lt;/code&gt; it will also pass option &lt;code&gt;input&lt;/code&gt;, and if a &lt;code&gt;Backbone.Camera&lt;/code&gt; exists, it will be tied to it. This function also acts as a toggle when placing a sprite over a tile where another exists. The existing one is removed. This ensures only one tile (static sprite) exists at one location.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;width(), height()&lt;/code&gt;: Return the size of the world in pixels.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;getWorldIndex(object)&lt;/code&gt;: Calculates the index position of a tile based on coordinates. Argument &lt;code&gt;object&lt;/code&gt; must contain &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, or be a model with those attributes. The index is calculated with formula &lt;code&gt;height * x/tileWidth + y/tileHeight&lt;/code&gt;. This method is used to set the &lt;code&gt;id&lt;/code&gt; of tile sprites.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;getWorldCol(x), getWorldRow(y)&lt;/code&gt;: Returns the tile position in columns or rows of a coordinate.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;findAt(x, y, [type], [exclude], [collision])&lt;/code&gt;: Finds the first sprite at the specified coordinate. Use for collision detection. Optional arguments allow you to filter what to look for. Set &lt;code&gt;type&lt;/code&gt; to &lt;code&gt;character&lt;/code&gt; to find moving sprites, or &lt;code&gt;tile&lt;/code&gt; to find tiles. Set &lt;code&gt;exclude&lt;/code&gt; to the id of the sprite you want to exclude from the search. In a collision detection scheme, this is usually the id of the sprite you are checking against. Set &lt;code&gt;collision&lt;/code&gt; to true to find only tiles that have their &lt;code&gt;collision&lt;/code&gt; flag set.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;filterAt(x, y, [type], [exclude], [collision])&lt;/code&gt;: Same as &lt;code&gt;findAt&lt;/code&gt; but returns the list of all matching sprites instead of the first.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;findCollidingAt(x, y)&lt;/code&gt;: Finds a colliding tile. Just like calling &lt;code&gt;findAt(x, y, "tile", null, true)&lt;/code&gt;.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;findCollisions()&lt;/code&gt;: Finds collisions for a given set of collision map.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Events&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;attach&lt;/code&gt;: Triggered when the sprite is attached to the engine. Will trigger the &lt;code&gt;attach&lt;/code&gt; method of all sprites in the world.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;detach&lt;/code&gt;: Triggered when the sprite is detached to the engine. Will trigger the &lt;code&gt;detach&lt;/code&gt; event of all sprites in the world.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;tap&lt;/code&gt;:
          Trigerred when the user taps or clicks on the canvas. The callback will be passed the DOM event extended with these properties: &lt;code&gt;canvas&lt;/code&gt;, &lt;code&gt;canvasX&lt;/code&gt;, &lt;code&gt;canvasY&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt;, &lt;code&gt;worldX&lt;/code&gt; and &lt;code&gt;worldY&lt;/code&gt;.
        &lt;/li&gt;
        &lt;li&gt;&lt;code&gt;key&lt;/code&gt;: Trigerred on a keyup event. The event callback will be passed the DOM event as argument.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;How it works&lt;/h4&gt;
      &lt;p&gt;
        Sprites can be added and removed via methods &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt;. Sprites are automatically attached to the &lt;a href="#documentation-Engine" target="_blank"&gt;Backbone.Engine&lt;/a&gt; the world is attached to. Sprites then have properties &lt;code&gt;engine&lt;/code&gt; and &lt;code&gt;world&lt;/code&gt; set as back-reference. In each request frame, the same mechanics apply as for sprites attached directly to an engine; methods &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;draw&lt;/code&gt; are called for each sprite. The exception is for static sprites which are only updated/redrawn when required (see below).
      &lt;/p&gt;
      &lt;p&gt;
        Internally, the world keeps sprites into a collection stored in property &lt;code&gt;sprites&lt;/code&gt;. It further splits sprites into 2 collections for faster lookup:
      &lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;staticSprites&lt;/code&gt;: Background sprites that have no animation. These are usually same-sized tiles. Sprites that have their &lt;code&gt;static&lt;/code&gt; attribute set to &lt;code&gt;true&lt;/code&gt; will be put in this collection. Sprites are given an &lt;code&gt;id&lt;/code&gt; determined by their position (column and row). The collection is ordered and indexed on &lt;code&gt;id&lt;/code&gt; allowing for fast lookup on a pair of x/y coordinates. In addition, these sprites are drawn on a background canvas only drawn when required (i.e. world is panned).&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;dynamicSprites&lt;/code&gt;: Animated tiles and characters. Their &lt;code&gt;static&lt;/code&gt; attribute must be set to &lt;code&gt;false&lt;/code&gt; to fall in this collection. These sprites are given unique &lt;code&gt;id&lt;/code&gt; attributes based on their name (i.e. &lt;code&gt;mario.1&lt;/code&gt;). They are not indexed therefore lookup has an order of N. Keep the number of sprites here to a minimum.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;
        A world is measured in tiles via attributes &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, &lt;code&gt;tileWidth&lt;/code&gt; and &lt;code&gt;tileHeight&lt;/code&gt;. Call methods &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; to get the size in pixels. Attributes &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; determine the origin in pixels (top-left corner) and allow the world to be panned consequently changing the viewport.
      &lt;/p&gt;
      &lt;div class="alert alert-info"&gt;
        Note: If you define an animated tile, make sure its &lt;code&gt;static&lt;/code&gt; attribute is set to false to prevent redraws every animation frame. Also ensure the width of tile sprites match that of world attributes &lt;code&gt;tileWidth&lt;/code&gt; and &lt;code&gt;tileHeight&lt;/code&gt;.
      &lt;/div&gt;
      &lt;h4&gt;Sprites&lt;/h4&gt;
      &lt;p&gt;
        When the world is created, sprites are instantiated in method &lt;code&gt;spawnSprites&lt;/code&gt;. Each sprite instance is attached to the engine. Sprites then have properties &lt;code&gt;engine&lt;/code&gt; and &lt;code&gt;world&lt;/code&gt; set pointing to those respective objects.
      &lt;/p&gt;
      &lt;p&gt;
        Sprites can be categorized with attribute &lt;code&gt;type&lt;/code&gt; as to identify one another when they interact with each other. Sprites of type &lt;code&gt;tile&lt;/code&gt; are usually static and obstacles. Sprites of type &lt;code&gt;character&lt;/code&gt; are usually dynamic and moving sprites.
      &lt;/p&gt;
      &lt;p&gt;
        You can add sprites with method &lt;code&gt;add&lt;/code&gt; which delegates to the &lt;code&gt;sprites&lt;/code&gt; collection's &lt;code&gt;add&lt;/code&gt; method. It takes care of passing the &lt;code&gt;world&lt;/code&gt; as option.
      &lt;/p&gt;
      &lt;p&gt;
        You can also use method &lt;code&gt;cloneAtPosition(sprite, x, y)&lt;/code&gt;. It takes as argument an existing sprite, and coordinates. It will clone the sprite and place it at the specified coordinates passing &lt;code&gt;world&lt;/code&gt; and &lt;code&gt;input&lt;/code&gt; as options. If the sprite has its &lt;code&gt;hero&lt;/code&gt; attribute set to &lt;code&gt;ture&lt;/code&gt;, and if a &lt;code&gt;Backbone.Camera&lt;/code&gt; exists, it will be tied to it. Backbone.WorldEditor&lt;/code&gt; uses this function for instance.
      &lt;/p&gt;
      &lt;p&gt;
        Methods &lt;code&gt;getWorldIndex&lt;/code&gt;, &lt;code&gt;getWorldCol&lt;/code&gt; and &lt;code&gt;getWorldRow&lt;/code&gt; can be used to find the position of a sprite. A sprite's &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; attributes determine their position relative to the world origin.
      &lt;/p&gt;
      &lt;h4&gt;Background and Tiles&lt;/h4&gt;
      &lt;p&gt;
        The background of a world is composed of same-size tiles defined by attributes &lt;code&gt;tileWidth&lt;/code&gt; and &lt;code&gt;tileHeight&lt;/code&gt;. A tile is usually a non-animated sprite with its &lt;code&gt;static&lt;/code&gt; attribute set to true. The model &lt;code&gt;id&lt;/code&gt; is the position of the sprite on screen (column and row). As such, there can only be one tile per location.
      &lt;/p&gt;
      &lt;h4&gt;Character Sprites&lt;/h4&gt;
      &lt;p&gt;
        Characters are sprites that interact with their environment. &lt;a href="#documentation-Character"&gt;Backbone.Character&lt;/a&gt; and &lt;a href="#documentation-Hero"&gt;Backbone.Hero&lt;/a&gt; are character sprites. Character sprite models usually have teir &lt;code&gt;type&lt;/code&gt; attribute set to &lt;code&gt;character&lt;/code&gt;. You are free to use attribute &lt;code&gt;type&lt;/code&gt; to classify your sprites.
      &lt;/p&gt;
      &lt;h4&gt;Collision detection&lt;/h4&gt;
      &lt;p&gt;Internally sprite positions are stored in a &lt;a href="https://github.com/asaarinen/qtree" target="_blank"&gt;QuadTree&lt;/a&gt;. As a sprite moves, its position in the QuadTree is updated.
      &lt;/p&gt;
      &lt;p&gt;Three methods exist to detect collisions.&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;findAt(x, y, [type], [exclude], [collision])&lt;/code&gt;:
          Find the first sprite touching the given point or &lt;code&gt;null&lt;/code&gt; if none are found. Optional arguments can be passed for limiting the lookup:
          &lt;ul&gt;
            &lt;li&gt;&lt;code&gt;type&lt;/code&gt;: Optional. If set, will only lookup sprites matching that type. Typical values are &lt;code&gt;character&lt;/code&gt; or &lt;code&gt;tile&lt;/code&gt;.&lt;/li&gt;
            &lt;li&gt;&lt;code&gt;exlcude&lt;/code&gt;: Optional. The sprite model's &lt;code&gt;id&lt;/code&gt; to exclude in lookup.&lt;/li&gt;
            &lt;li&gt;&lt;code&gt;collision&lt;/code&gt;: Optional. Boolean indicating whether to only include sprites that have the &lt;code&gt;collision&lt;/code&gt; attribute explicitly set to &lt;code&gt;true&lt;/code&gt;.
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;code&gt;filterAt(x, y, [type], [exclude], [collision])&lt;/code&gt;: Same as a above but finds all sprites touching the given point. Returns an array of sprites.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;findCollisions(map, [type], [exclude], [collision])&lt;/code&gt;:
          Detects collisions on sprites for a set of named coordinates.
          Optional arguments are the same as above. Argument &lt;code&gt;map&lt;/code&gt; is an array of objects that is passed in, and passed out. A map object must contain:
          &lt;ul&gt;
            &lt;li&gt;&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;: Coordinates to detect the collision.&lt;/li&gt;
            &lt;li&gt;&lt;code&gt;dir&lt;/code&gt;: The lookout direction: &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt; or &lt;code&gt;left&lt;/code&gt;.&lt;/li&gt;
            &lt;li&gt;&lt;code&gt;sprites&lt;/code&gt;: Array of detected colliding sprites. Reset/initialized to [] every call.&lt;/li&gt;
            &lt;li&gt;&lt;code&gt;sprite&lt;/code&gt;: The closest sprite based on the lookout direction.&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;
        Look at the code in &lt;code&gt;Backbone.Character&lt;/code&gt; and &lt;code&gt;Backbone.Hero&lt;/code&gt; classes for examples on how to perform collision detection.
      &lt;/p&gt;
      &lt;h4&gt;Persistence&lt;/h4&gt;
      &lt;p&gt;
        The world model attributes contain all that is necessary to persist the state of the world to disk, or in the cloud. Calling the &lt;code&gt;save&lt;/code&gt; method first serializes the sprite collection from the &lt;code&gt;sprites&lt;/code&gt; property into the &lt;code&gt;sprites&lt;/code&gt; attribute. It calls the &lt;code&gt;toSave&lt;/code&gt; method on each sprite to save their position and state. It then delegates to the backbone model's &lt;code&gt;save&lt;/code&gt; method to save to a server or local storage in JSON format. See the Backbone documentation for details.
      &lt;/p&gt;
      &lt;p&gt;
        The world can be restored by calling &lt;code&gt;spawnSprites&lt;/code&gt; passing as argument a saved world in JSON format. For example, file &lt;code&gt;super-mario-world/level-1-1.js&lt;/code&gt; contains the level in JSON format. It is set in global variable &lt;code&gt;_world&lt;/code&gt;. The world can be restarted anytime with this line of code:
      &lt;/p&gt;
      &lt;pre&gt;world.set(window._world).spawnSprites();&lt;/pre&gt;
      &lt;h4&gt;Usage&lt;/h4&gt;
      &lt;pre&gt;
</code></pre>

<p>var mario = new Backbone.Mario({
    x: 400, y: 400, floor: 500
  });</p>

<p>var world = new Backbone.World({
    width: 30, height: 18,
    tileWidth: 32, tileHeight: 32,
    backgroundColor: "rgba(66, 66, 255, 1)"
  });
  world.add(mario);</p>

<p>var engine = new Backbone.Engine();
  engine.add(world);

        </p><p>
          A sprite (mario) is first created and added it the world. The world is then added to the engine. This is taken from file <code>mario/main.js</code> for the Mario example.
        </p>
        
      

<pre><code>  &lt;div id="documentation-WorldEditor" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3&gt;Backbone.WorldEditor&lt;/h3&gt;
      &lt;pre&gt;new Backbone.WorldEditor([attributes], [options])&lt;/pre&gt;
      &lt;p&gt;
        &lt;code&gt;Backbone.WorldEditor&lt;/code&gt; is a model which displays a palette of sprites and allows the user to edit a &lt;code&gt;Backbone.World&lt;/code&gt; instance by placing and removing sprites. Also allows the user to pan the world. In the Super Mario Bros demo, an editor is drawn at the bottom of the world replacing the &lt;a href="#documentation-Input"&gt;Backbone.Input&lt;/a&gt;. Like sprites and world, it must be added to the &lt;code&gt;Backbone.Engine&lt;/code&gt; to render. The palette will page automatically if there are too many sprites.
      &lt;/p&gt;
      &lt;p&gt;
        &lt;img src="docs/world-editor.png" class="img-responsive" alt="Backbone.Input" /&gt;
      &lt;/p&gt;
      &lt;h4&gt;Attributes&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;x, y&lt;/code&gt;: Top-left placement position in pixels of the editor on the canvas.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;width, height&lt;/code&gt;: Size of editor in pixels.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;tileWidth, tileHeight&lt;/code&gt;: Size of sprites drawn in the palette.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;padding&lt;/code&gt;: Padding in pixels around sprites.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;backgroundColor&lt;/code&gt;: Background color of the editor.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;selectColor&lt;/code&gt;: Background and outline color of a selected sprite.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;selected&lt;/code&gt;: The name of the cuurrently selected sprite.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;spriteNames&lt;/code&gt;: Ordered array of sprite names in the palette.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Options&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;world&lt;/code&gt;: The Backbone.World to edit.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;debugPanel&lt;/code&gt;: Optional. If passed will output mouse coordinates.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Events&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;attach&lt;/code&gt;: Triggered when the sprite is attached to the engine. Will start listening to user input.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;detach&lt;/code&gt;: Triggered when the sprite is detached to the engine. Will stop listening to user input.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;How it works&lt;/h4&gt;
      &lt;p&gt;
        The palette is drawn as a series of tiles left to right, top to bottom. Each tile is a sprite. The sprite may be bigger than the specified tile size, in which case it will be resized to fit the &lt;code&gt;tileWidth&lt;/code&gt; and &lt;code&gt;tileHeight&lt;/code&gt; attributes.
      &lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div id="documentation-Character" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3&gt;Backbone.Character&lt;/h3&gt;
      &lt;pre&gt;new Backbone.Character([attributes], [options])&lt;/pre&gt;
      &lt;p&gt;
        The &lt;code&gt;Backbone.Character&lt;/code&gt; is a sub-classed &lt;code&gt;Backbone.Sprite&lt;/code&gt; which implements an animated character with elementary AI (artificial intelligence) and physics. AI is limited to moving left, right, jumping/gravity and dying. Direction changes occur with collisions against an obstacle; either a tile or another character. You are free to extend the AI by subclassing it.
      &lt;/p&gt;
      &lt;div class="alert alert-info"&gt;
        A &lt;code&gt;Backbone.Character&lt;/code&gt; must live inside a &lt;code&gt;Backbone.World&lt;/code&gt;.
      &lt;/div&gt;
      &lt;h4&gt;Attributes&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;x, y&lt;/code&gt;: Position of the sprite.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;floor&lt;/code&gt;: Set this value to prevent the character to fall outisde of the world due to gravity. By default it is null meaning the character will be removed from the world if it falls below the bottom of the world.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;ceiling&lt;/code&gt;: Analogous to &lt;ocde&gt;floor&lt;/ocde&gt; but for exiting the world from above.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;width, height&lt;/code&gt;: Size of the sprite in pixels. Defaults to  32 x 32.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;paddingLeft, paddingRight, paddingTop, paddingBottom&lt;/code&gt;: Optional. Internal padding to account for empty space inside the tile of a sprite. Useful to specify empty zones for collision detection.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;sequenceIndex&lt;/code&gt;: The current animation sequence frame. Automatically set.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;name&lt;/code&gt;: Name of the sprite.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;type&lt;/code&gt;: Type of sprite. Defaults to character.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;spriteSheet&lt;/code&gt;: Id of sprite sheet.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;state&lt;/code&gt;: Current animation. Starts with &lt;code&gt;idle-right&lt;/code&gt;.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;collision&lt;/code&gt;: Boolean indicating whether it can be detected by other sprites. Defaults to true.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;static&lt;/code&gt;: Set to false for the World to draw every animation frame.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;visible&lt;/code&gt;: Set to true for the sprite to be drawn.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;zIndex&lt;/code&gt;: Optional. Specifies the drawing order. Higher value is drawn above sprites with lower values. Default is 0.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;velocity, acceleration&lt;/code&gt;: Current horizontal movement. Controlled by the AI in &lt;code&gt;update&lt;/code&gt;.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;yVelocity, yAcceleration&lt;/code&gt;: Current vertical movement. Controlled by the AI in &lt;cpde&gt;update&lt;/cpde&gt;.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;health&lt;/code&gt;: Amount of health the character has. When &lt;code&gt;health&lt;/code&gt; is 0, the is "knocked-out" and dies. Defaults to 1.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;attackDamage&lt;/code&gt;: This is the amount of damage the character does to an opponent. Will reduce their health by this value. Defaults to 1.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;aiDelay&lt;/code&gt;: Time in ms between AI calls.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Methods&lt;/h4&gt;
      &lt;p&gt;
        &lt;code&gt;Backbone.Character&lt;/code&gt; inherits all methods from &lt;code&gt;Backbone.Sprite&lt;/code&gt;. Here are additional methods, and ones with a different signature.
      &lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;getStateInfo([state])&lt;/code&gt;: Decomposes &lt;code&gt;state&lt;/code&gt; into move and direction components. For example &lt;code&gt;walk-left&lt;/code&gt; would be decomposed into &lt;code&gt;{mov:"walk", mov2: null, dir:"left", opo:"right"}&lt;/code&gt;. If argument &lt;code&gt;state&lt;/code&gt; is omitted, the &lt;code&gt;state&lt;/code&gt; attribute is used instead. See &lt;a href="#documentation-Hero"&gt;Backbone.Hero&lt;/a&gt; for a more detailed description.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;buildState(mov, [mov2], [dir])&lt;/code&gt;: Helper to construct and return a dash-separated state string. Ignores falsy values. For instance &lt;code&gt;buildState("walk", "left")&lt;/code&gt; and &lt;code&gt;buildState("walk", null, "left")&lt;/code&gt; both return &lt;code&gt;walk-left&lt;/code&gt;.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;update(dt)&lt;/code&gt;: Handles the character movements and collision detection. Also calls the &lt;code&gt;ai&lt;/code&gt; function.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;ai(dt)&lt;/code&gt;: Implements the AI. Is called at an interval defined by attribute &lt;code&gt;aiDelay&lt;/code&gt;.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;updateSequenceIndex(dt)&lt;/code&gt;: Returns the new &lt;code&gt;sequenceIndex&lt;/code&gt; (animation frame). Called by &lt;code&gt;update&lt;/code&gt;.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;toggleDirection(dirIntent)&lt;/code&gt;: Invokes a &lt;code&gt;left&lt;/code&gt; or &lt;code&gt;right&lt;/code&gt; direction change.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;startNewAnimation(state, attrs, done)&lt;/code&gt;: Changes the state of the character starting a new animation. Pass hash &lt;code&gt;attrs&lt;/code&gt; to set attributes at the same time. Callback &lt;code&gt;done&lt;/code&gt; is called once the animation is complete. Useful for performing only one animation sequence.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;hit(sprite, [dir], [dir2])&lt;/code&gt;: Function invoked usually by a &lt;code&gt;hit&lt;/code&gt; event. Implement this to determine what happens when another &lt;code&gt;sprite&lt;/code&gt; hits the character. Argument &lt;code&gt;dir&lt;/code&gt; is the primary direction of the hit (&lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt; or &lt;code&gt;bottom&lt;/code&gt;). Argument &lt;code&gt;dir2&lt;/code&gt; is the secondary direction. In top-left for example, it would be left. &lt;code&gt;dir2&lt;/code&gt; can also be &lt;code&gt;attack&lt;/code&gt; in which case &lt;code&gt;health&lt;/code&gt; is reduced by &lt;code&gt;attackDamage&lt;/code&gt; amount.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;hurt(sprite, [dir], [dir2])&lt;/code&gt;: Function invoked when the character gets attacked and has remaining health. The character bounces back.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;knockout(sprite, [dir], [dir2])&lt;/code&gt;: Function invoked when the sprite gets knocked out of the world. The sprite is litterally knocked out updside down. This function is called when &lt;code&gt;health&lt;/code&gt; is 0.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Events&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;attach&lt;/code&gt;: Triggered when the sprite is attached to the world. Turns on the AI.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;detach&lt;/code&gt;: Triggered when the sprite is detached to the world. Turns off the AI meaning the character will not move.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;hit&lt;/code&gt;: Trigger this event on the &lt;code&gt;Backbone.Character&lt;/code&gt; to indicate a hit with another character. Delegates to the &lt;code&gt;hit&lt;/code&gt; method above. For example, &lt;code&gt;Backbone.Hero&lt;/code&gt; executes this when he lands on a character: &lt;code&gt;sprite.trigger("hit", this, "top", "left");&lt;/code&gt;.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;change:health&lt;/code&gt;: Whenever the character health decreases method &lt;code&gt;hurt&lt;/code&gt; gets called. If &lt;code&gt;health&lt;/code&gt; reaches 0, method &lt;code&gt;knockout&lt;/code&gt; gets called instead.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;How it works&lt;/h4&gt;
      &lt;p&gt;
        During an animation frame, it is important to understand the method and event sequence. First, the &lt;code&gt;update&lt;/code&gt; method is called. It may then call the &lt;code&gt;ai&lt;/code&gt; method if the &lt;code&gt;aiDelay&lt;/code&gt; internal is reached. Afterwhich collision detection is performed. At that point, the character may trigger &lt;code&gt;hit&lt;/code&gt; events on other characters. Those may in turn trigger a &lt;code&gt;hit&lt;/code&gt; event on the character. The character position and velocities are updated, and finally, the character model is set. The &lt;code&gt;update&lt;/code&gt; method then returns &lt;code&gt;true&lt;/code&gt; to tell the engine to draw the sprite, or &lt;code&gt;false&lt;/code&gt; to prevent a redraw.
      &lt;/p&gt;
      &lt;div class="alert alert-info"&gt;
        These events are synchroneous, and will occur before the &lt;code&gt;update&lt;/code&gt; method is completely executed.
        Therefore methods &lt;code&gt;ai&lt;/code&gt;, &lt;code&gt;hit&lt;/code&gt;, &lt;code&gt;hurt&lt;/code&gt; and &lt;code&gt;knockout&lt;/code&gt; may set the character model and abort the update. To abort the update, those methods set property &lt;code&gt;cancelUpdate&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.
      &lt;/div&gt;
      &lt;h4&gt;Example&lt;/h4&gt;
      &lt;p&gt;
        In the Super Mario Bros example, look at file &lt;code&gt;enemies.js&lt;/code&gt;. There are implementations for basic characters in that game. The &lt;code&gt;hit&lt;/code&gt; method implements collision detection outcome, notably when Mario lands on a character. In the case of a Mushroom, it gets &lt;em&gt;squished&lt;/em&gt;. When a turtle shell is sliding, it would cause a knockout.
      &lt;/p&gt;
      &lt;pre&gt;
</code></pre>

<p>...
hit: function(sprite, dir, dir2) {
  if (this._handlingSpriteHit) return this;
  this._handlingSpriteHit = sprite;</p>

<p>var cur = this.getStateInfo(),
      opo = dir == "left" ? "right" : (dir == "right" ? "left" : (dir == "top" ? "bottom" : "top"));</p>

<p>if (sprite.get("hero")) {
    if (dir == "top")
      this.squish.apply(this, arguments);
  } else if (sprite.get("state").indexOf("slide") != -1 ||
            sprite.get("type") == "tile" &amp;&amp; dir == "bottom" &amp;&amp; sprite.get("state") == "bounce") {
    this.knockout.apply(this, arguments);
  }
  sprite.trigger("hit", this, opo);</p>

<p>this._handlingSpriteHit = undefined;
  return this;
}
...

        </p><p>
          The <code>hit</code> method will in turn trigger a hit event on the sprite which caused the collision.
          That sprite may in turn trigger a hit event. To avoid the possibility of inifite callback loops, private property <code>_handleSpriteHit</code> is used.
        </p>
        
      

<pre><code>  &lt;div id="documentation-Hero" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3&gt;Backbone.Hero&lt;/h3&gt;
      &lt;pre&gt;new Backbone.Hero([attributes], [options])&lt;/pre&gt;
      &lt;p&gt;
        The &lt;code&gt;Backbone.Hero&lt;/code&gt; is a sub-classed &lt;code&gt;Backbone.Character&lt;/code&gt; which implements a controlable character with input and physics. Its playability is based on that of Mario in the Nintendo classic Super Mario Bros. Currently, only the small Mario is implemented.
      &lt;/p&gt;
      &lt;div class="alert alert-info"&gt;
        A &lt;code&gt;Backbone.Hero&lt;/code&gt; must live inside a &lt;code&gt;Backbone.World&lt;/code&gt;.
      &lt;/div&gt;
      &lt;h4&gt;Attributes&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;x, y&lt;/code&gt;: Position of the sprite.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;floor&lt;/code&gt;: Set this value to prevent the character to fall outisde of the world due to gravity. By default it is null meaning the character will be removed from the world if it falls below the bottom of the world.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;ceiling&lt;/code&gt;: Analogous to &lt;ocde&gt;floor&lt;/ocde&gt; but for exiting the world from above.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;width, height&lt;/code&gt;: Size of the sprite in pixels. Defaults to  32 x 64.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;paddingLeft, paddingRight, paddingTop, paddingBottom&lt;/code&gt;: Optional. Internal padding to account for empty space inside the tile of a sprite. Useful to specify empty zones for collision detection. &lt;ocde&gt;paddingTop&lt;/ocde&gt; is set to 32 to start as Mario is small.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;sequenceIndex&lt;/code&gt;: The current animation sequence frame. Automatically set.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;name&lt;/code&gt;: Name of the sprite. Defaults to hero.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;hero&lt;/code&gt;: Boolean set to true indicating this character sprite is the hero. Backbone.World will detect this and pass the Backbone.Input instance for taking user input.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;type&lt;/code&gt;: Type of sprite. Defaults to character.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;spriteSheet&lt;/code&gt;: Id of sprite sheet.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;state&lt;/code&gt;: Current animation. Starts with idle-right.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;collision&lt;/code&gt;: Boolean indicating whether it can be detected by other sprites. Defaults to true.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;static&lt;/code&gt;: Set to false for the World to draw every animation frame.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;visible&lt;/code&gt;: Set to true for the sprite to be drawn.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;zIndex&lt;/code&gt;: Optional. Specifies the drawing order. Higher value is drawn above sprites with lower values. Default is 0.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;velocity, acceleration&lt;/code&gt;: Current horizontal movement. Do not set.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;yVelocity, yAcceleration&lt;/code&gt;: Current vertical movement. Do not set.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;health&lt;/code&gt;: Amount of health as an integer. When set to 0, the character is knocked out and dies. Defaults to 1.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;healthMax&lt;/code&gt;: The maximum allowed health. Defaults to 2.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;dead&lt;/code&gt;: Boolean flag indicating if the sprite is dead.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;attackDamage&lt;/code&gt;: This is the amount of damage the hero does to an opponent. Will reduce their health by this value. Defaults to 1.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;ignoreInput&lt;/code&gt;: Flag to prevent the hero from accepting user input. Defaults to false.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;canAttack&lt;/code&gt;: Flag indicating whether the B button will result in an attack. Defaults to false.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;canTurnInJump&lt;/code&gt;: By default the hero cannot turn in air (jumping or falling). Set this to tru to enable it.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Options&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;input&lt;/code&gt;: Optional. A &lt;code&gt;Backbone.Input&lt;/code&gt; instance to allow control of the character with the keyboard (left and right arrows, z and x) or via touch events on the on-screen drawn gamepad.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Methods&lt;/h4&gt;
      &lt;p&gt;
        &lt;code&gt;Backbone.Hero&lt;/code&gt; inherits all methods from &lt;code&gt;Backbone.Sprite&lt;/code&gt; and &lt;code&gt;Backbone.Character&lt;/code&gt;. In addition, it provides these methods you can override:
      &lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;dirToggled(dirIntent)&lt;/code&gt;: Called when the user presses the left or right buttons. Argument &lt;code&gt;dirIntent&lt;/code&gt; maye be left or right. The default implementation handles left/right movements.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;buttonAToggled&lt;/code&gt;: Called when the user presses the A button (rigt-most blue on pad, or x on keyboard). The default implementation handles jumping.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;buttonBToggled&lt;/code&gt;: Called when the user presses the B button (left-most red on pad, or z on keyboard). The default implementation handles running and attacking (if &lt;code&gt;canAttack&lt;/code&gt; is set to true).&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Events&lt;/h4&gt;
      &lt;p&gt;
        &lt;code&gt;Backbone.Hero&lt;/code&gt; has the same events as &lt;code&gt;Backbone.Character&lt;/code&gt;.
      &lt;/p&gt;
      &lt;h4&gt;How it works&lt;/h4&gt;
      &lt;p&gt;
        Attribute &lt;code&gt;state&lt;/code&gt; determines the current animation. A state is a pair of move and direction. For example &lt;code&gt;idle-right&lt;/code&gt;, &lt;code&gt;walk-left&lt;/code&gt; and &lt;code&gt;jump-right&lt;/code&gt;. Method &lt;code&gt;getStateInfo&lt;/code&gt; will decompose the state for you into those components.
      &lt;/p&gt;
      &lt;p&gt;
        With attribute &lt;code&gt;nextState&lt;/code&gt;, we are able to implement tweens, or in-between animations. For example, holding the right arrow button puts the hero in a &lt;code&gt;walk-right&lt;/code&gt; state (and &lt;code&gt;slide-right&lt;/code&gt; next state). Releasing the right arrow button transitions to the &lt;code&gt;slide-right&lt;/code&gt; state (and &lt;code&gt;idle-right&lt;/code&gt; next state) for quick decelration until velocity reaches 0 to fall to the &lt;code&gt;idle-right&lt;/code&gt; state. If instead the left arrow button is pressed, we transition to the &lt;code&gt;skid-left&lt;/code&gt; state (and &lt;code&gt;walk-left&lt;/code&gt; next state) for quicker decelartion until velocity reaches 0 to then accelerate in the opposite direction to fall in the &lt;code&gt;walk-left&lt;/code&gt; state (and &lt;code&gt;slide-left&lt;/code&gt; next state).
      &lt;/p&gt;
      &lt;p&gt;
        Holding an arrow button and the A button (z on keyboard) allows the character to run. Its state becomes &lt;code&gt;run-right&lt;/code&gt; (or &lt;code&gt;run-left&lt;/code&gt;). Pressing the B button allows the character to jump (&lt;code&gt;jump-left&lt;/code&gt; or &lt;code&gt;jump-right&lt;/code&gt;). Hold the B button to jump higher. You can control the direction and distance jumped with the arrow buttons. And like in the real game, a jump while running will go higher to cover more distance.
      &lt;/p&gt;
      &lt;p&gt;
        Physics are implemented with attributes &lt;code&gt;velocity&lt;/code&gt;, &lt;code&gt;acceleration&lt;/code&gt;, &lt;code&gt;yVelocity&lt;/code&gt; and &lt;code&gt;yAcceleration&lt;/code&gt; measured in pixels per seconds. The two first control horizontal translations over time where a positive &lt;code&gt;velocity&lt;/code&gt; indicates a move to the right, and negative to the left. The latter two control vertical translations where a positive &lt;code&gt;yVelocity&lt;/code&gt; indicates a move downwards, and negative upwards.
      &lt;/p&gt;
      &lt;p&gt;
        Each animation have targets of these properties when required. They are omitted otherwise (i.e. &lt;code&gt;walk-right&lt;/code&gt; has no &lt;code&gt;yVelocity&lt;/code&gt; or &lt;code&gt;yAcceleration&lt;/code&gt;). The &lt;code&gt;update&lt;/code&gt; method updates the model attributes according to the targets configured on the current animation. When &lt;code&gt;state&lt;/code&gt; changes to another animation, so do the targets, and so follow the actual velocities over time to reach their targets. This gives the character momentum.
      &lt;/p&gt;
      &lt;p&gt;
        Gravity is implemented with a positive &lt;code&gt;yAcceleration&lt;/code&gt;. Unless atop a tile, our character will fall. However it is constrained by the extent of the &lt;code&gt;Backbone.World&lt;/code&gt; it is contained in. And will therefore stop falling when the bottom is reached.
      &lt;/p&gt;
      &lt;h4&gt;Collisions&lt;/h4&gt;
      &lt;p&gt;
        Our character detects collisions either from tiles or other characters to constrain its movements. It does so using collision detection method &lt;code&gt;findCollidings&lt;/code&gt; from &lt;code&gt;Backbone.World&lt;/code&gt;. Every &lt;code&gt;update&lt;/code&gt;, collisions with other sprites are detected on the outline of the sprite:
      &lt;/p&gt;
      &lt;p&gt;
        &lt;img class="img-responsive" src="docs/hero-collisions.png" alt="Hero Collisions" /&gt;
      &lt;/p&gt;
      &lt;p&gt;
        Collisions are only handled when necessary. For instance, when jumping collisions are handled top and right only. The decision is based on looking at &lt;code&gt;velocity&lt;/code&gt; and &lt;code&gt;yVelocity&lt;/code&gt;. For gravity, a check is performed every time at the bottom of the sprite to land or to fall.
      &lt;/p&gt;
      &lt;pre&gt;
</code></pre>

<p>var bottomWorld = this.world.height() + tileHeight,
    floor = this.get("floor") || bottomWorld,
    bottomY = Math.min(floor, bottomWorld);</p>

<p>for (i = 0; i &lt; this.collisionMap.bottom.sprites.length; i++) {
  sprite = this.collisionMap.bottom.sprites[i];
  bottomY = Math.min(bottomY, sprite.getTop(true));
  if (sprite.get("type") == "platform") bottomPlatform = sprite;
}</p>

<p>...</p>

<p>if (yVelocity &gt; 0 &amp;&amp; heroBottomY &gt;= bottomY) {
  // Stop falling
  land(bottomY);
  for (i = 0; i &lt; this.collisionMap.bottom.sprites.length; i++)
    this.collisionMap.bottom.sprites[i].trigger("hit", this, "top", cur.dir);
  if (this.cancelUpdate) return true;
} else if (cur.mov != "jump" &amp;&amp; yVelocity == 0 &amp;&amp; heroBottomY &lt; bottomY) {
  // Start falling if no obstacle below
  attrs.nextState = state;
  attrs.state = this.buildState("jump", cur.mov2, cur.dir);
} else if (yVelocity == 0 &amp;&amp; heroBottomY == bottomY) {
  // On a floating platform - same vertical velocity
  if (bottomPlatform)
    relativeVelocity = bottomPlatform.get("velocity");
}

          </p><p>
            When an obstacle is hit, the character stops moving. Its <code>x</code> is anchored, and <code>velocity</code> set to 0.
          </p>
          <pre>
if (velocity &gt;= 0) {
  // Stop if obstacle to the right
  var rightX = this.world.width();
  for (i = 0; i &lt; this.collisionMap.right.sprites.length; i++)
    if (heroTopY &gt; 0 )
      rightX = Math.min(rightX, this.collisionMap.right.sprites[i].getLeft(true));

<p>if (heroRightX &gt;= rightX) {
    attrs.velocity = velocity = 0;
    attrs.x = x = rightX - heroWidth - paddingLeft;
    for (i = 0; i &lt; this.collisionMap.right.sprites.length; i++)
      this.collisionMap.right.sprites[i].trigger("hit", this, "left", cur.mov2);
    if (this.cancelUpdate) return true;
  }
}
</p></pre>
          <p>
            A collision with other sprites triggers an <code>hit</code> event on that sprite. The event hanlder will receive the colliding sprite (hero), and its relative position where the hit occured (left of the enemie sprite in this case).
          </p>
          <h4>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage</h4>
          <p>
            This excerpt is taken from the Mario example.
          </p>
          <pre>
  Backbone.Mario = Backbone.Hero.extend({
    defaults: _.extend({}, Backbone.Hero.prototype.defaults, {
      name: "mario",
      spriteSheet: "mario"
    })
  });

<p>var canvas = document.getElementById("foreground");</p>

<p>var spriteSheets = new Backbone.SpriteSheetCollection([{
    id: "mario",
    img: "#mario",
    tileWidth: 32,
    tileHeight: 64,
    tileColumns: 21,
    tileRows: 6
  }]).attachToSpriteClasses();</p>

<p>var input = new Backbone.Input({
    drawTouchpad: true,
    drawPause: true
  });</p>

<p>var mario = new Backbone.Mario({
    x: 400, y: 400
  }, {
    input: input
  });</p>

<p>var world = new Backbone.World({
    width: 30, height: 18,
    tileWidth: 32, tileHeight: 32,
    backgroundColor: "rgba(66, 66, 255, 1)"
  });
  world.add(mario);</p>

<p>var engine = new Backbone.Engine({}, {
    canvas: canvas,
    input: input
  });
  engine.add([
    world,
    input
  ]);
</p></pre>
        
      

<pre><code>  &lt;div id="documentation-Camera" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3&gt;Backbone.Camera&lt;/h3&gt;
      &lt;pre&gt;new Backbone.Camera([attributes], [options])&lt;/pre&gt;
      &lt;p&gt;
        &lt;code&gt;Backbone.Camera&lt;/code&gt; is a model which ensures a sprite, the subject, is always in the viewport (the canvas). It pans the &lt;code&gt;Backbone.World&lt;/code&gt; when the character steps out of a window in the viewport. &lt;code&gt;Backbone.Camera&lt;/code&gt; must be added to the engine (not the world).
      &lt;/p&gt;
      &lt;h4&gt;Attributes&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;left, right, top, bottom&lt;/code&gt;: Coordinates of the window with respect to the drawn canvas.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Options&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;subject&lt;/code&gt;: The sprite to keep in the viewport.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;world&lt;/code&gt;: The Backbone.World.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Methods&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;update(dt)&lt;/code&gt;: No-op. Simply returns false for no redraw.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;draw(context)&lt;/code&gt;: No-op.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;maybePan()&lt;/code&gt;: Called when the &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; position of the subject changes. Ensures the subject is within the specified window, otherwise pans the world.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Events&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;attach&lt;/code&gt;: Triggered when the sprite is attached to the engine. Starts monitoring the subject and pans the &lt;code&gt;Backbone.World&lt;/code&gt; when necessary.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;detach&lt;/code&gt;: Triggered when the sprite is detached to the engine. Stops monitoring the subject.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Usage&lt;/h4&gt;
      &lt;pre&gt;
</code></pre>

<p>var spriteSheets = new Backbone.SpriteSheetCollection({
  id: "mario",
  img: "#mario",
  tileWidth: 32,
  tileHeight: 64,
  tileColumns: 21,
  tileRows: 6
});
var mario = new Backbone.Mario();
var world = new Backbone.World();
var camera = new Backbone.Camera(
  {left: 200, right: 600, top: 100, bottom: 50},
  {subject: mario, world: world}
);
world.add(mario);
var engine = new Backbone.Engine();
engine.add([world, camera]);

        
      </p>

<pre><code>  &lt;div id="documentation-Clock" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3&gt;Backbone.Clock&lt;/h3&gt;
      &lt;p&gt;
        &lt;code&gt;Backbone.Clock&lt;/code&gt; is a model which ticks at a set time interval. Attribute &lt;code&gt;ticks&lt;/code&gt; stores an integer tick value that gets incremented every interval. Useful for synchronizing sprite animations.
      &lt;/p&gt;
      &lt;h4&gt;Attributes&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;ticks&lt;/code&gt;: Initial tick value. An integer that gets incremented every interval.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;delay&lt;/code&gt;: Interval between ticks.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Methods&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;update(dt)&lt;/code&gt;: Updates the ticks.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;draw(context)&lt;/code&gt;: No-op. Simply returns the model.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Events&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;attach&lt;/code&gt;: Triggered when the sprite is attached to the engine. Starts ticking.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;detach&lt;/code&gt;: Triggered when the sprite is detached to the engine. Stops ticking.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Usage&lt;/h4&gt;
      &lt;pre&gt;
</code></pre>

<p>var clock = new Backbone.Clock({delay: 2000});
clock.on("change:ticks", function() {
  console.log("tick", clock.get("ticks");
});

          </p><p>
            As an example, look at the Super Mario Bros example, question blocks and pennies are all synced on the same clock. These sprites are sub-classes of <code>Backbone.AnimatedTile</code>. Instances create a Backbone.Clock if one does not exist. Otherwise, they find the existing one by that name and reuse it.
          </p>
          <pre>
Backbone.AnimatedTile = Backbone.Tile.extend({
  initialize: function(attributes, options) {
    Backbone.Tile.prototype.initialize.apply(this, arguments);
    this.on("attach", this.onAttach, this);
    this.on("detach", this.onDetach, this);
  },
  onAttach: function() {
    if (!this.engine) return;
    this.onDetach();

<pre><code>this.clock = this.engine.findWhere({name: "animatedTileClock"});

if (!this.clock)
  this.clock = this.engine.add(new Backbone.Clock({name: "animatedTileClock", delay: 200}));

this.listenTo(this.clock, "change:ticks", this.updateAnimationIndex);
</code></pre>

<p>},
  onDetach: function() {
    if (this.clock) this.stopListening(this.clock);
    this.clock = undefined;
  },
  update: function(dt) {
    return true;
  },
  updateAnimationIndex: function() {
    var animation = this.getAnimation(),
        sequenceIndex = this.get("sequenceIndex") || 0;
    if (!animation) return;
    this.set("sequenceIndex", sequenceIndex &lt; animation.sequences.length-1 ? sequenceIndex + 1 : 0);
  }
});
</p></pre>
        
      

<pre><code>  &lt;div id="documentation-Element" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3&gt;Backbone.Element&lt;/h3&gt;
      &lt;p&gt;
        &lt;code&gt;Backbone.Element&lt;/code&gt; is a model that mimics a rudimentary DOM element.
        Currently, it supports these features:
      &lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;Fixed position specified by top-left &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.&lt;/li&gt;
        &lt;li&gt;Optional background color and rounded corners.&lt;/li&gt;
        &lt;li&gt;Optional image.&lt;/li&gt;
        &lt;li&gt;Optional text.&lt;/li&gt;
        &lt;li&gt;Can be animated with easing functions. Supported animations are: translation, fade in and fade out.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Attributes&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;x, y&lt;/code&gt;: Top left corner of button.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;width, height&lt;/code&gt;: Size of button.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;backgroundColor&lt;/code&gt;: Fill style of the button. Set to &lt;code&gt;transparent&lt;/code&gt; to see thru.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;borderRadius&lt;/code&gt;: Border radius in pixels for rounded corners.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;img&lt;/code&gt;: The &lt;code&gt;Image&lt;/code&gt; object or element id selector of the image to find in the DOM (i.e. &lt;code&gt;#icons&lt;/code&gt;). A pointer to the Image object is then stored in property &lt;code&gt;img&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;imgX, imgY, imgWidth, imgHeight&lt;/code&gt;: Bounding box of image location in source image.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;imgMargin&lt;/code&gt;: Offset in pixels to apply when drawing the image inside the button.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;text&lt;/code&gt;: Text to draw. If empty, not text is drawn.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;textPadding, textLineHeight&lt;/code&gt;: Padding around the text and line height in pixels.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;textContextAttributes&lt;/code&gt;: Canvas text styling properties. Will be set on the canvas context before calling &lt;code&gt;fillText&lt;/code&gt;. Consult &lt;a href="http://www.html5canvastutorials.com/tutorials/html5-canvas-text-font-size/" target="_blank"&gt;HTML5 fillText documentation&lt;/a&gt; for details.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;easing&lt;/code&gt;: Easing function to use as defined in &lt;code&gt;Backbone.EasingFunctions&lt;/code&gt; (see below).&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;easingTime&lt;/code&gt;: Duration of the animation in ms. Defaults to 1000ms.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;opacity&lt;/code&gt;: Opacity of the element. 1 for fully visible, 0 for invisible and in-between for translucent. This value is changed by &lt;code&gt;fadeIn&lt;/code&gt; and &lt;code&gt;fadeOut&lt;/code&gt; animations.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;scale&lt;/code&gt;: Zoom-in, zoom-out scale to apply to the element. Default is 1. Can be used to defined your own animation (see Backbone.Button's &lt;code&gt;pressed&lt;/code&gt; animation below).&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Methods&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;update(dt)&lt;/code&gt;: Draws the element and handles animations.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;onUpdate(dt)&lt;/code&gt;: Not defined by default. If deinfed, called at the end of &lt;code&gt;update&lt;/code&gt;. It must return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; to determine whether to draw the element or not.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;draw(context, options)&lt;/code&gt;: Draws the element.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;onDraw(context, options)&lt;/code&gt;: Not defined by default. If deinfed, called at the end of &lt;code&gt;draw&lt;/code&gt;.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;drawText(b, context, options)&lt;/code&gt;: Called by &lt;code&gt;draw&lt;/code&gt; to draw text. Argument &lt;code&gt;b&lt;/code&gt; is the JSONized model (&lt;code&gt;this.toJSON()&lt;/code&gt;) defining the context. You can call this to draw extra text if you implemented method &lt;code&gt;onDraw&lt;/code&gt;.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;overlaps(x, y):&lt;/code&gt;: Checks to see if the sprite overlaps with the passed coordinates. Returns a Boolean.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;moveTo(x, y, callback)&lt;/code&gt;: Translation animation. Will move the element from the current position to the specified &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; position using the &lt;code&gt;easing&lt;/code&gt; function and &lt;code&gt;easingTime&lt;/code&gt; duration.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;fadeIn(callback)&lt;/code&gt;: Animates a fade in. Starts with an opacity of 0 going up to 1.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;fadeOut(callback)&lt;/code&gt;: Animates a fade out. Starts with an opacity of 1 going down to 0.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Events&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;attach&lt;/code&gt;: Triggered when the sprite is attached to the engine. Starts listening to user input.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;detach&lt;/code&gt;: Triggered when the sprite is detached to the engine. Stops listening to user input.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Animations&lt;/h4&gt;
      &lt;p&gt;
        Animations are driven by attributes &lt;code&gt;easing&lt;/code&gt; and &lt;code&gt;easingTime&lt;/code&gt;. The first defines the easing function to use and the second the duration in ms. These functions are found in &lt;code&gt;Backbone.EasingFunctions&lt;/code&gt; and are:
        &lt;ul&gt;
          &lt;li&gt;&lt;code&gt;linear&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;easeInQuad&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;easeOutQuad&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;easeInOutQuad&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;easeInCubic&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;easeOutCubic&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;easeInOutCubic&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;easeInQuart&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;easeOutQuart&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;easeInOutQuart&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;easeInQuint&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;easeOutQuint&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;easeInOutQuint&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
        Easing functions return a value between 0 and 1.
      &lt;/p&gt;
      &lt;p&gt;
        You can create your own animations pretty easily. Look at the code for examples.
      &lt;/p&gt;
      &lt;h4&gt;Usage&lt;/h4&gt;
      &lt;pre&gt;
</code></pre>

<p>TO DO...

        
      </p>

<pre><code>  &lt;div id="documentation-Button" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3&gt;Backbone.Button&lt;/h3&gt;
      &lt;p&gt;
        &lt;code&gt;Backbone.Button&lt;/code&gt; is a &lt;code&gt;Backbone.Element&lt;/code&gt; which listens to tap/click events and triggers a &lt;code&gt;tap&lt;/code&gt; event when pressed. When pressed there is a grow-shrink animation to give the user feedback.
      &lt;/p&gt;
      &lt;h4&gt;Usage&lt;/h4&gt;
      &lt;pre&gt;
</code></pre>

<p>var button = new Backbone.Button({
  x: 4, y: 4, width: 52, height: 52, borderRadius: 5,
  img: "#icons", imgX: 0, imgY: 0, imgWidth: 32, imgHeight: 32, imgMargin: 10
});
button.on("tap", function() {
  console.log("button tapped!");
});

        
      </p>

<pre><code>  &lt;div id="documentation-DebugPanel" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3&gt;Backbone.DebugPanel&lt;/h3&gt;
      &lt;p&gt;
        &lt;code&gt;Backbone.DebugPanel&lt;/code&gt; is a Backbone model on which you set attributes to be dumped on screen. Upon draw, it will &lt;code&gt;JSON.stringify&lt;/code&gt; attributes.
      &lt;/p&gt;
      &lt;h4&gt;Events&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;update(dt)&lt;/code&gt;: No-op. Simply returns true.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;draw(context)&lt;/code&gt;: Draws the debug information on screen.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;attach&lt;/code&gt;: Triggered when the sprite is attached to the engine.&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;detach&lt;/code&gt;: Triggered when the sprite is detached to the engine.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;Usage&lt;/h4&gt;
      &lt;pre&gt;
</code></pre>

<p>var debugPanel = new Backbone.DebugPanel();
var engine = new Backbone.Engine({}, {
  debugPanel: debugPanel
});
engine.add(debugPanel);</p>

<p>debugPanel.set({hello: "Word"});
// Draws this on screen
// {"fps": 58, "ct": 7, "hello": "World"}</p>

<p>debugPanel.set({hello: "Dolly"});
// {"fps": 58, "ct": 7, "hello": "Dolly"}</p>

<p>debugPanel.unset("hello");
// {"fps": 58, "ct": 7}

          </p><p>
            In the above example, the debug panel is created. It is added to the engine as a model to draw. It is also passed as an option to the engine so it can output <code>fps</code> and <code>ct</code> (cycle time).
          </p>
          <p>
            We manually add attribute <code>hello</code> to be tracked. Whenever it changes, so does the print out on screen. Use <code>unset</code> to remove a tracked attribute.
          </p>
          <h4>
<a id="conditional-usage" class="anchor" href="#conditional-usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conditional Usage</h4>
          <p>
            It is recommended that you support the non-existence of the debug panel with an <code>if (this.debugPanel)</code> statement before setting. For example, when you extend a class, pass in the debug panel as an option. Then, in your code, check to see if it exists. For example, this is done in the <code>Backbone.Engine.draw</code> method:
          </p>
          <pre>if (this.debugPanel) this.debugPanel.set({fps: this.fps, ct: this.cycleTime});</pre>
          <p>
            This supports the case where the debug panel is never created (<code>debugPanel</code> = <code>undefined</code>), such as in production.
          </p>
        
      

<pre><code>  &lt;div id="documentation-Shapes" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h3&gt;Shape functions&lt;/h3&gt;
      &lt;p&gt;
        File &lt;code&gt;shapes.js&lt;/code&gt; contains helper functions to draw elementary shapes in the 2d drawing context of a canvas. You are free to use direct methods on the context to draw. These are provided as convenience. The functions are added to the global scope, under &lt;code&gt;window&lt;/code&gt;. Supported functions are:
      &lt;/p&gt;
      &lt;pre&gt;
</code></pre>

<p>drawRect(ctx, x, y, width, height, fill, stroke)
drawCircle(ctx, x, y, radius, fill, stroke)
drawRoundRect(ctx, x, y, width, height, radius, fill, stroke)

          </p><p>
            I encourage you to add your own. If you do, respect these recommendations:
          </p>
          <ul>
            <li>Functions take as first argument <code>ctx</code> the drawing context.</li>
            <li>Second and third arguments should be <code>x</code> and <code>y</code> coordinates.</li>
            <li>Last arguments should be <code>fill</code> the fill style, and <code>stroke</code> the stroke style. They should be optional if possible.</li>
          </ul>
        
      

<pre><code>  &lt;div id="mobile-devices" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h1&gt;Mobile Devices&lt;/h1&gt;
      &lt;p&gt;
        Backbone Game Engine was built for mobile first.
      &lt;/p&gt;
      &lt;h3&gt;Touch Events&lt;/h3&gt;
      &lt;p&gt;
        &lt;a href="#documentation-Engine"&gt;Backbone.Engine&lt;/a&gt;, &lt;a href="#documentation-Input"&gt;Backbone.Input&lt;/a&gt;, &lt;a href="#documentation-Button"&gt;Backbone.Button&lt;/a&gt; and &lt;a href="#documentation-WorldEditor"&gt;Backbone.WorldEditor&lt;/a&gt; support touch and mouse events transparently. Works on Android, iOS and Windows.
      &lt;/p&gt;
      &lt;h3&gt;Viewport resizing and canvas centering&lt;/h3&gt;
      &lt;p&gt;
        On mobile devices, the &lt;code&gt;meta&lt;/code&gt; tag &lt;code&gt;viewport&lt;/code&gt; is set to 960 pixels wide.
        On iOS, Android and Windows mobile devices, this will ensure the canvas is full width.
        The HTML file contains the necessary header tags to ensure everything works.
        You can change the viewport width value to whatever you want.
      &lt;/p&gt;
</code></pre>

<pre>
&lt;meta name="viewport" content="width=960, user-scalable=no"/&gt;
&lt;meta name="mobileoptimized" content="0" /&gt;
</pre>

<pre><code>      &lt;p&gt;
        Not all screens have the same aspec ratio.
        To take care of the height, you can change the height of the canvas upon start by calling the global function &lt;code&gt;adjustViewport()&lt;/code&gt; (see file &lt;code&gt;adjust-viewport.js&lt;/code&gt; for details).
      &lt;/p&gt;
</code></pre>

<pre>
var canvas = document.getElementById("foreground");
adjustViewport(canvas);
</pre>

<pre><code>      &lt;p&gt;
        If you want to maintain the aspect ratio, pass true. The canvas will be centered on screen.
      &lt;/p&gt;
</code></pre>

<pre>
var canvas = document.getElementById("foreground");
adjustViewport(canvas, true);
</pre>

<pre><code>    &lt;p&gt;
      On desktop the &lt;code&gt;viewport&lt;/code&gt; meta tag is ignored.
      &lt;code&gt;adjustViewport&lt;/code&gt; will center the canvas, even handling resizes.
      It will try to reduce the height of the canvas if too tall unless you omit the &lt;code&gt;keepRatio&lt;/code&gt; argument.
    &lt;/p&gt;
    &lt;h3&gt;Web App&lt;/h3&gt;
    &lt;p&gt;
      These meta tags are set to enable Web App support:
    &lt;/p&gt;
</code></pre>

<pre>
&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt;
&lt;meta name="mobile-web-app-capable" content="yes" /&gt;
&lt;meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/&gt;
</pre>

<pre><code>    &lt;p&gt;
      To suggest users to put add the home page to the home screen, checkout this great plugin:
      &lt;a href="https://github.com/cubiq/add-to-homescreen" target="_blank"&gt;Cubiq's Add To Homescreen&lt;/a&gt;.
    &lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div id="going-offline" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h1&gt;Going Offline&lt;/h1&gt;
      &lt;p&gt;
        With &lt;a href="https://developer.apple.com/library/safari/documentation/iphone/conceptual/safarijsdatabaseguide/offlineapplicationcache/offlineapplicationcache.html" target="_blank"&gt;HTML Application Cache&lt;/a&gt;, you can go offline with your game. &lt;a href="super-mario-bros/index.html" target="_blank"&gt;Super Mario Bros level 1-1&lt;/a&gt; uses the application cache. The first time your browser loads that page, it will save the web page, along with all assets in its application cache. Subsequent visits will load these from the application cache instead of the server.
      &lt;/p&gt;
      &lt;div class="alert alert-info"&gt;
        Note: Application Cache only works when loaded from a server. It will not if you have forked the repo, and are loading the file from your disk (&lt;code&gt;file:///&lt;/code&gt;). That's good because under development, we want to load the new code every refresh.
      &lt;/div&gt;
      &lt;p&gt;
        If you have Google Chrome, open the console and you will see this:
      &lt;/p&gt;
      &lt;pre&gt;
</code></pre>

<p>Creating Application Cache with manifest <a href="http://martindrapeau.github.io/backbone-game-engine/super-mario-bros/offline.appcache">http://martindrapeau.github.io/backbone-game-engine/super-mario-bros/offline.appcache</a>
Application Cache Checking event martindrapeau.github.io/:1
Application Cache Downloading event martindrapeau.github.io/:1
Application Cache Progress event (0 of 23) <a href="http://martindrapeau.github.io/backbone-game-engine/3rd/qtree.js">http://martindrapeau.github.io/backbone-game-engine/3rd/qtree.js</a>
Application Cache Progress event (1 of 23) <a href="http://martindrapeau.github.io/backbone-game-engine/src/input.js">http://martindrapeau.github.io/backbone-game-engine/src/input.js</a>
...
Application Cache Progress event (22 of 23) <a href="http://martindrapeau.github.io/backbone-game-engine/super-mario-bros/super-mario-enemies-2x.png">http://martindrapeau.github.io/backbone-game-engine/super-mario-bros/super-mario-enemies-2x.png</a>
Application Cache Progress event (23 of 23)
Application Cache Cached event 

          </p><p>
            Subsequent times, you will see this:
          </p>
          <pre>
Document was loaded from Application Cache with manifest <a href="http://martindrapeau.github.io/backbone-game-engine/super-mario-bros/offline.appcache">http://martindrapeau.github.io/backbone-game-engine/super-mario-bros/offline.appcache</a>
Application Cache Checking event
Application Cache NoUpdate event
</pre>
        <h3>
<a id="manifest-file" class="anchor" href="#manifest-file" aria-hidden="true"><span class="octicon octicon-link"></span></a>Manifest File</h3>
        <p>
          Using an Application Cache is dead simple. First you must add the <code>manifest</code> attribute to your HTML tag. It points to the manifest file:
        </p>
        <pre>
&lt;!doctype html&gt;
&lt;html manifest="offline.appcache"&gt;
    &lt;head&gt;
</pre>
          Second, create the <code>manifest</code> file. It contains files that must be cached. For example here is the <code>offline.appcache</code>:
        
        <pre>
CACHE MANIFEST

<h1>
<a id="version-011-c-2014-2015-martin-drapeau" class="anchor" href="#version-011-c-2014-2015-martin-drapeau" aria-hidden="true"><span class="octicon octicon-link"></span></a>Version 0.11 (c) 2014-2015 Martin Drapeau</h1>

<p>../3rd/qtree.js
../3rd/underscore.js
../3rd/backbone.native.js
../3rd/backbone.js</p>

<p>../src/input.js
../src/shapes.js
../src/core.js
../src/world.js
../src/local-storage.js
../src/camera.js
../src/editor.js
../src/hero.js</p>

<p>mario.js
tiles.js
artifacts.js
enemies.js
display.js
level_1-1.js
main.js</p>

<p>super-mario-2x.png
super-mario-tiles-2x.png
super-mario-enemies-2x.png
icons.png
</p></pre>
          <p>
            If you have server requests, you can add a <code>NETWORK</code> section. Consult the docs for details.
          </p>
          <p>
            Fianally, the comment with <code>Version 0.11</code> is important. When a new version of Super Mario Bros level 1-1 is released, the version number is increased to force the browser to reload the files. It will also trigger an <code>updateready</code> event which gets captured to show a download button. That informs the user a new version is ready to be downloaded. Clicking on that button simply refreshes the browser to reload the new version.
          </p>
        
      

<pre><code>  &lt;div id="persistence" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h1&gt;Persistence&lt;/h1&gt;
      &lt;p&gt;
        Backbone offers RESTful persistence via &lt;a href="http://backbonejs.org/#Sync" target="_blank"&gt;Backbone.sync&lt;/a&gt;. Models have methods &lt;code&gt;fetch&lt;/code&gt; and &lt;code&gt;save&lt;/code&gt; to retrieve/send the model/collection JSONified data to/from the server. As such, you can easily implement server-side persistence using well established RESTful standards.
      &lt;/p&gt;
      &lt;p&gt;
        In our Super Mario Bros example, we use &lt;a href="https://developer.apple.com/library/safari/documentation/iPhone/Conceptual/SafariJSDatabaseGuide/Name-ValueStorage/Name-ValueStorage.html" target="_blank"&gt;local storage&lt;/a&gt; instead. This is done by overriding &lt;code&gt;Backbone.World&lt;/code&gt; methods &lt;code&gt;save&lt;/code&gt; and &lt;code&gt;fetch&lt;/code&gt;. See file &lt;code&gt;src/local-storage.js&lt;/code&gt; for details.
      &lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div id="performance" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h1&gt;Performance and Debugging&lt;/h1&gt;
      &lt;p&gt;
        HTML5 canvas has come a long way in terms on performance. Browser implementations of canvas now offer impressive performance. On mobile, Apple leads the pack being able to sustain a 60fps for the Super Mario Bros example. However on Android, frame rates drop fast to the 30s when the background needs to be redrawn. On Surface performance seems good on newer models, however on first generation RT models, as slow as on Android tablets.
      &lt;/p&gt;
      &lt;p&gt;
        This being said, there are things you can do to ensure the best performance.
      &lt;/p&gt;
      &lt;h4&gt;Keep cycle time below 16ms&lt;/h4&gt;
      &lt;p&gt;
        That is the time you have between redraws, 60 times a second. The &lt;code&gt;Backbone.Engine&lt;/code&gt; will report the frame rate (fps), and cycle time (ct) if you add and attach a &lt;code&gt;Backbone.DebugPanel&lt;/code&gt;. Make sure to use it. If you see &lt;code&gt;fps&lt;/code&gt; go down while &lt;code&gt;ct&lt;/code&gt; goes up, then your &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;draw&lt;/code&gt; times must be too long. You can time the &lt;code&gt;update&lt;/code&gt; time to pinpoint the issue.
      &lt;/p&gt;
      &lt;h4&gt;Play well with Javascript Garbage Collection&lt;/h4&gt;
      &lt;p&gt;
        You can't avoid it. You will leak memory. Every call made by &lt;code&gt;requestAnimationFrame&lt;/code&gt; creates a function scope. It does so 60 times a second and it will need to be garbage collected. The browser will pause to collect garbage.
      &lt;/p&gt;
      &lt;p&gt;
        You can however control the leakage rate. Try to create objects upfront, and pool resources as much as possible. That's why sprite sheets are shared among sprites. If you ever see that your game jerks, at an even interval (i.e. every 30s), then you are probably being hit by the garbage collector recuperating large amounts of memory (&gt;10MB).
      &lt;/p&gt;
      &lt;p&gt;
        You can use the Timeline tool in Chrome/Safari Developer Tools to identify this. Record a session and once done, you can apply a filter &lt;code&gt;gc&lt;/code&gt; to filter on garbage collection events. You will notice they are at evenly spaced intervals. On my machine, for Super Mario Bros, 3.5MB is collected every 4s on average. There is no jerk. No jerk on a tablet means healthy memory management.
      &lt;/p&gt;
      &lt;p&gt;
        Some further references and good resources on performance:
      &lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href="http://blog.artillery.com/2012/10/browser-garbage-collection-and-framerate.html" target="_blank"&gt;Browser Garbage Collection and Frame Rate&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="https://www.scirra.com/blog/76/how-to-write-low-garbage-real-time-javascript" target="_blank"&gt;How to write low garbage real-time Javascript&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="http://www.html5rocks.com/en/tutorials/canvas/performance/" target="_blank"&gt;Improving HTML5 Canvas Performance&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div id="publishing" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h1&gt;Publishing your Game&lt;/h1&gt;
      &lt;h2&gt;On the Web&lt;/h2&gt;
      &lt;p&gt;
        If you forked this repo, your game is already published on the web on your Github page under &lt;code&gt;[username].github.io/backbone-game-engine&lt;/code&gt;.
      &lt;/p&gt;
      &lt;p&gt;
        If you own an iPad or iPhone, you can add it to the home screen as a Web app. It will open in full-screen and if you've implemented an Application Cache, it will work offline too.
      &lt;/p&gt;
      &lt;h2&gt;On iOS and Android&lt;/h2&gt;
      &lt;p&gt;
        Backbone Game Engine was built to run in &lt;a href="https://www.ludei.com/cocoonjs/" target="_blank"&gt;CocoonJS&lt;/a&gt; canvas+. You can try out Super Mario Bros level 1-1 in the &lt;a href="http://support.ludei.com/hc/en-us/articles/201048463-CocoonJS-launcher-user-guide" target="_blank"&gt;CocoonJS launcher&lt;/a&gt; by pointing to the zip file at this URL: http://martindrapeau.github.io/cocoon-mario/cocoon-mario.zip.
        &lt;/p&gt;
</code></pre>

<pre>
http://martindrapeau.github.io/cocoon-mario/cocoon-mario.zip
</pre>

<pre><code>      &lt;p&gt;
        Checkout the Github repo &lt;a href="" target="_blank"&gt;cocoon-mario&lt;/a&gt;.
        It can be used as the basis for your own native game on iOS or Android.
      &lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div id="change-log" class="row"&gt;
    &lt;div class="col-md-12"&gt;
      &lt;h1&gt;Change Log&lt;/h1&gt;
      &lt;h4&gt;0.40 - TBD&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;Upcoming release to include bug fixes, improvements and new features to come following the release to iOS of Ludo's Quest.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;0.30 - 2015-03-22&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;Backbone.Element - a rudimentary DOM element with image, text and animations.&lt;/li&gt;
        &lt;li&gt;Backbone.World now uses a QuadTree for collision detection.&lt;/li&gt;
        &lt;li&gt;Removed dependence on hammer.js. Backbone.Engine now triggers tap and key events.&lt;/li&gt;
        &lt;li&gt;Complete rewrite of Backbone.Input. Removed its pause button.&lt;/li&gt;
        &lt;li&gt;Complete rewrite of Backbone.Character.&lt;/li&gt;
        &lt;li&gt;Complete rewrite of Backbone.Hero.&lt;/li&gt;
        &lt;li&gt;Backbone.Editor now resizes sprites to fit in the specified tileWidth and tileHeight.&lt;/li&gt;
        &lt;li&gt;Rewrite of adjustViewport global function to work cross-device.&lt;/li&gt;
        &lt;li&gt;Official support of CocoonJS canvas+.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;0.21 - 2015-02-06&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li&gt;Sprite padding&lt;/li&gt;
        &lt;li&gt;More efficient gamepad drawing&lt;/li&gt;
        &lt;li&gt;Editor: paging, shrink large sprites, highlight tiles&lt;/li&gt;
        &lt;li&gt;World: z-index, tap event,key event, fixed background image, improved sprite lookup, bug fixes&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h4&gt;0.20 - 2014-12-31&lt;/h4&gt;
      &lt;p&gt;
        Major improvements including:
        &lt;ul&gt;
          &lt;li&gt;Performance improvements.&lt;/li&gt;
          &lt;li&gt;Fast sprite lookup.&lt;/li&gt;
          &lt;li&gt;Faster dynamic and static drawing.&lt;/li&gt;
          &lt;li&gt;Efficient collision detection.&lt;/li&gt;
          &lt;li&gt;Character and hero knockout and dying.&lt;/li&gt;
          &lt;li&gt;Bug fixes.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/p&gt;
      &lt;h4&gt;0.11 - 2014-11-12&lt;/h4&gt;
      &lt;p&gt;
        Adjust viewport on orientation change, and center canvas.
      &lt;/p&gt;
      &lt;h4&gt;0.10 - 2014-05-19&lt;/h4&gt;
      &lt;p&gt;
        Initial release.
      &lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;

&lt;/div&gt;

&lt;div class="col-md-3"&gt;
  &lt;div id="sidebar" class="bs-sidebar affix"&gt;
    &lt;ul class="nav bs-sidenav"&gt;
      &lt;li class="active"&gt;&lt;a href="#introduction"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#getting-started"&gt;Getting Started&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#documentation"&gt;Reference&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#documentation-Engine"&gt;&amp;nbsp;&amp;nbsp;Backbone.Engine&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#documentation-SpriteSheet"&gt;&amp;nbsp;&amp;nbsp;Backbone.SpriteSheet&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#documentation-SpriteSheetCollection"&gt;&amp;nbsp;&amp;nbsp;Backbone.SpriteSheetCollection&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#documentation-Sprite"&gt;&amp;nbsp;&amp;nbsp;Backbone.Sprite&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#documentation-Input"&gt;&amp;nbsp;&amp;nbsp;Backbone.Input&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#documentation-World"&gt;&amp;nbsp;&amp;nbsp;Backbone.World&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#documentation-WorldEditor"&gt;&amp;nbsp;&amp;nbsp;Backbone.WorldEditor&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#documentation-Character"&gt;&amp;nbsp;&amp;nbsp;Backbone.Character&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#documentation-Hero"&gt;&amp;nbsp;&amp;nbsp;Backbone.Hero&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#documentation-Camera"&gt;&amp;nbsp;&amp;nbsp;Backbone.Camera&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#documentation-Clock"&gt;&amp;nbsp;&amp;nbsp;Backbone.Clock&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#documentation-Element"&gt;&amp;nbsp;&amp;nbsp;Backbone.Element&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#documentation-Button"&gt;&amp;nbsp;&amp;nbsp;Backbone.Button&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#documentation-DebugPanel"&gt;&amp;nbsp;&amp;nbsp;Backbone.DebugPanel&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#documentation-Shapes"&gt;&amp;nbsp;&amp;nbsp;Shape functions&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#mobile-devices"&gt;Mobile Devices&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#going-offline"&gt;Going Offline&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#persistence"&gt;Persistence&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#performance"&gt;Performance&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#publishing"&gt;Publishing&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#change-log"&gt;Change Log&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;br/&gt;

&lt;footer class="navbar navbar-default"&gt;
    &lt;p class="navbar-text navbar-left"&gt;
      &amp;copy; 2014 &lt;a href="http://martindrapeau.tumblr.com/"&gt;Martin Drapeau.&lt;/a&gt;
      &lt;a href="https://github.com/martindrapeau/backbone-game-engine/blob/gh-pages/LICENSE"&gt;Licensed under MIT.&lt;/a&gt;
    &lt;/p&gt;
    &lt;p class="navbar-text navbar-right"&gt;Written in Montréal, Canada.&lt;/p&gt;
    &lt;p class="navbar-text navbar-right"&gt;&amp;nbsp;&lt;/p&gt;
&lt;/footer&gt;
</code></pre>

<p>
</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/bbert81/backbone-game-engine">Backbone-game-engine</a> is maintained by <a href="https://github.com/bbert81">bbert81</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
